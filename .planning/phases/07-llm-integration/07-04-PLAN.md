---
phase: 07-llm-integration
plan: 04
type: execute
wave: 3
depends_on: [07-02]
files_modified: [src/cfg/summary.rs, src/cfg/mod.rs, src/cli/mod.rs]
autonomous: true

must_haves:
  truths:
    - "System provides natural language summaries of control flow"
    - "LLM can understand path semantics without parsing raw block sequences"
  artifacts:
    - path: "src/cfg/summary.rs"
      provides: "Template-based natural language generation for paths"
      min_lines: 80
      exports: ["summarize_path", "describe_block", "summarize_cfg"]
    - path: "src/cfg/mod.rs"
      provides: "Public exports for summary module"
      exports: ["summarize_path", "describe_block"]
    - path: "src/cli/mod.rs"
      provides: "PathSummary with populated summary field"
      contains: ["summary: Some("]
  key_links:
    - from: "PathSummary::from_with_cfg"
      to: "cfg::summarize_path"
      via: "cfg::summarize_path(&cfg, &path)"
      pattern: "summarize_path.*cfg.*path"
    - from: "summarize_path"
      to: "describe_block"
      via: "path.blocks.iter().map(describe_block)"
      pattern: "describe_block.*terminator"
---

<objective>
Control flow natural language summaries

Purpose: Generate concise natural language descriptions of execution paths so LLMs can understand control flow semantics without parsing raw block sequences. Uses template-based generation (no external LLM dependency).

Output: New `src/cfg/summary.rs` module with `summarize_path()` and `describe_block()` functions, integrated into `PathSummary.summary` field.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-llm-integration/07-RESEARCH.md
@src/cli/mod.rs
@src/cfg/mod.rs
@src/cfg/paths.rs
@src/output/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Create summary module with path description functions</name>
  <files>src/cfg/summary.rs</files>
  <action>
    Create new file `src/cfg/summary.rs` with template-based natural language generation:

    ```rust
    //! Natural language summaries of control flow structures

    use crate::cfg::{Cfg, Path, PathKind, BlockId, Terminator, BlockKind};
    use petgraph::graph::NodeIndex;

    /// Generate a natural language summary of a path
    ///
    /// Produces concise descriptions like:
    /// - "Entry → validate → return success (3 blocks)"
    /// - "Entry → validate → (error_path) → return (5 blocks)"
    pub fn summarize_path(cfg: &Cfg, path: &Path) -> String {
        if path.blocks.is_empty() {
            return "Empty path".to_string();
        }

        let block_descs: Vec<String> = path.blocks.iter()
            .map(|&bid| describe_block(cfg, bid))
            .collect();

        // Truncate long paths for readability
        let flow = if block_descs.len() <= 5 {
            block_descs.join(" → ")
        } else {
            format!(
                "{} → ... → {} ({} blocks)",
                block_descs.first().unwrap_or(&"?".to_string()),
                block_descs.last().unwrap_or(&"?".to_string()),
                path.len()
            )
        };

        // Add path kind context
        match path.kind {
            PathKind::Normal => format!("{} ({} blocks)", flow, path.len()),
            PathKind::Error => format!("{} → error ({} blocks)", flow, path.len()),
            PathKind::Degenerate => format!("{} → dead end ({} blocks)", flow, path.len()),
            PathKind::Unreachable => format!("Unreachable: {} ({} blocks)", flow, path.len()),
        }
    }

    /// Describe a single block in natural language
    fn describe_block(cfg: &Cfg, block_id: BlockId) -> String {
        // Find the node with this block_id
        let node_idx = match cfg.node_indices().find(|&n| cfg[n].id == block_id) {
            Some(idx) => idx,
            None => return format!("b{}(unknown)", block_id),
        };

        let block = &cfg[node_idx];

        // Description based on block kind
        let kind_desc = match block.kind {
            BlockKind::Entry => "entry",
            BlockKind::Exit => "exit",
            BlockKind::Normal => "",
        };

        // Description based on terminator
        let term_desc = match &block.terminator {
            Terminator::Return => "return".to_string(),
            Terminator::Goto { target } => format!("goto b{}", target),
            Terminator::SwitchInt { targets, otherwise } => {
                let count = targets.len();
                if count == 1 {
                    format!("if b{}|b{}", otherwise, targets[0])
                } else {
                    format!("switch ({} targets)", count)
                }
            }
            Terminator::Call { target } => {
                target.as_ref().map(|t| format!("call b{}", t)).unwrap_or_else(|| "call".to_string())
            }
            Terminator::Unreachable => "unreachable".to_string(),
            Terminator::Exception { .. } => "exception".to_string(),
        };

        // Combine descriptions
        match (kind_desc, term_desc.is_empty()) {
            ("", true) => format!("b{}", block_id),
            ("", false) => format!("b{}({})", block_id, term_desc),
            (kind, true) => format!("{}", kind),
            (kind, false) => format!("{}({})", kind, term_desc),
        }
    }

    /// Generate a high-level summary of a CFG
    ///
    /// Returns something like:
    /// "Function 'process_request' has 5 blocks, 2 exits. Entry: b0. Loops: 1."
    pub fn summarize_cfg(function_name: &str, cfg: &Cfg) -> String {
        use crate::cfg::{find_entry, find_exits, detect_natural_loops};

        let entry = find_entry(cfg)
            .map(|id| format!("b{}", id.index()))
            .unwrap_or_else(|| "unknown".to_string());

        let exits = find_exits(cfg);
        let exit_count = exits.count();

        let loops = detect_natural_loops(cfg);
        let loop_count = loops.len();

        format!(
            "Function '{}' has {} blocks, {} exit(s). Entry: {}. Loops: {}.",
            function_name,
            cfg.node_count(),
            exit_count,
            entry,
            loop_count
        )
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::cfg::{BasicBlock, BlockId, BlockKind, Terminator, Path, PathKind};
        use crate::cfg::edge::EdgeType;
        use petgraph::graph::DiGraph;

        #[test]
        fn test_summarize_path_linear() {
            let mut cfg: Cfg = DiGraph::new();

            // Create simple linear CFG: b0 -> b1 -> b2
            let b0 = cfg.add_node(BasicBlock {
                id: 0,
                kind: BlockKind::Entry,
                statements: vec![],
                terminator: Terminator::Goto { target: 1 },
                source_location: None,
            });

            let b1 = cfg.add_node(BasicBlock {
                id: 1,
                kind: BlockKind::Normal,
                statements: vec![],
                terminator: Terminator::Goto { target: 2 },
                source_location: None,
            });

            cfg.add_node(BasicBlock {
                id: 2,
                kind: BlockKind::Exit,
                statements: vec![],
                terminator: Terminator::Return,
                source_location: None,
            });

            cfg.add_edge(b0, b1, EdgeType::Fallthrough);
            cfg.add_edge(b1, b2, EdgeType::Fallthrough);

            let path = Path {
                path_id: "test".to_string(),
                blocks: vec![0, 1, 2],
                kind: PathKind::Normal,
                entry: 0,
                exit: 2,
            };

            let summary = summarize_path(&cfg, &path);

            assert!(summary.contains("entry"));
            assert!(summary.contains("return"));
            assert!(summary.contains("3 blocks"));
        }

        #[test]
        fn test_summarize_path_truncates_long() {
            let mut cfg: Cfg = DiGraph::new();

            // Create a 10-block path (should truncate)
            for i in 0..10 {
                let kind = if i == 0 { BlockKind::Entry } else if i == 9 { BlockKind::Exit } else { BlockKind::Normal };
                let term = if i == 9 { Terminator::Return } else { Terminator::Goto { target: i + 1 } };

                cfg.add_node(BasicBlock {
                    id: i,
                    kind,
                    statements: vec![],
                    terminator: term,
                    source_location: None,
                });
            }

            let path = Path {
                path_id: "test".to_string(),
                blocks: (0..10).collect(),
                kind: PathKind::Normal,
                entry: 0,
                exit: 9,
            };

            let summary = summarize_path(&cfg, &path);

            // Should truncate, not show all 10 blocks in flow
            assert!(summary.contains("..."));
            assert!(summary.contains("10 blocks"));
        }

        #[test]
        fn test_describe_block_entry() {
            let cfg: Cfg = DiGraph::new();
            let block_id = 0;

            let desc = describe_block(&cfg, block_id);

            assert!(desc.contains("b0"));
            assert!(desc.contains("(unknown)")); // No block with id=0 in empty CFG
        }

        #[test]
        fn test_summarize_cfg() {
            let cfg: Cfg = DiGraph::new();

            let summary = summarize_cfg("test_func", &cfg);

            assert!(summary.contains("test_func"));
            assert!(summary.contains("0 blocks"));
            assert!(summary.contains("Entry:"));
        }
    }
    ```

    This provides template-based NL generation without external dependencies.
  </action>
  <verify>
    grep -n "summarize_path\|describe_block\|summarize_cfg" src/cfg/summary.rs | wc -l  # Should be > 10
  </verify>
  <done>src/cfg/summary.rs created with summarize_path, describe_block, summarize_cfg functions</done>
</task>

<task type="auto">
  <name>Export summary functions from cfg module</name>
  <files>src/cfg/mod.rs</files>
  <action>
    Add the summary module and re-export functions:

    1. Add module declaration (around line 13, after `patterns`):
       ```rust
       pub mod summary;
       ```

    2. Add public exports (around line 29):
       ```rust
       pub use summary::{summarize_path, describe_block, summarize_cfg};
       ```

    This makes the functions available to the CLI module.
  </action>
  <verify>
    grep -n "pub mod summary\|pub use summary" src/cfg/mod.rs
  </verify>
  <done>summary module declared, functions exported from cfg module</done>
</task>

<task type="auto">
  <name>Integrate summary into PathSummary</name>
  <files>src/cli/mod.rs</files>
  <action>
    Update `PathSummary::from_with_cfg` to populate the `summary` field:

    Change the existing method to call `summarize_path`:

    ```rust
    pub fn from_with_cfg(path: crate::cfg::Path, cfg: &crate::cfg::Cfg) -> Self {
        use crate::cfg::NodeIndex;
        use crate::cfg::{summarize_path, NodeIndex as PetNodeIndex};
        use petgraph::graph::NodeIndex;

        // Generate natural language summary
        let summary = Some(summarize_path(cfg, &path));

        // Build PathBlock list with source locations
        let blocks: Vec<PathBlock> = path.blocks.iter().map(|&block_id| {
            // Find the node in the CFG
            let node_idx = cfg.node_indices()
                .find(|&n| cfg[n].id == block_id);

            let terminator = match node_idx {
                Some(idx) => format!("{:?}", cfg[idx].terminator),
                None => "Unknown".to_string(),
            };

            PathBlock {
                block_id,
                terminator,
            }
        }).collect();

        // Calculate source range from first and last blocks
        let source_range = Self::calculate_source_range(&path, cfg);

        let length = path.len();

        Self {
            path_id: path.path_id,
            kind: format!("{:?}", path.kind),
            length,
            summary,
            source_range,
            blocks,
        }
    }
    ```

    The key change is `summary: Some(summarize_path(cfg, &path))` instead of `summary: None`.
  </action>
  <verify>
    grep -n "summarize_path(cfg, &path)" src/cli/mod.rs
  </verify>
  <done>PathSummary.summary populated with natural language description</done>
</task>

<task type="auto">
  <name>Verify summary in JSON output</name>
  <files>src/cfg/summary.rs, src/cli/mod.rs</files>
  <action>
    Test that natural language summaries appear in JSON output:

    1. Run unit tests:
       ```bash
       cargo test summary --quiet 2>&1 | grep -E "(test result:|FAILED)"
       ```

    2. Build and test CLI output:
       ```bash
       cargo build --quiet
       ./target/debug/mirage paths --function test --output json | jq '.data.paths[0].summary'
       ```
       Expected: A string like "entry → goto b1 → return (3 blocks)"

    3. Verify truncation for long paths (test CFG should have short paths, so this tests basic functionality)

    Run all tests:
    ```bash
    cargo test --quiet 2>&1 | grep -E "(test result:|FAILED)"
    ```
  </action>
  <verify>
    ./target/debug/mirage paths --function test --output json 2>&1 | jq -e '.data.paths[0].summary'
  </verify>
  <done>JSON output includes summary field with natural language path description</done>
</task>

</tasks>

<verification>
1. New file `src/cfg/summary.rs` created with functions
2. Module exported from `src/cfg/mod.rs`
3. `summarize_path` generates concise NL descriptions
4. `describe_block` maps terminators to readable text
5. `summarize_cfg` provides function-level overview
6. JSON output includes populated `summary` field
7. Long paths are truncated (show "..." instead of all blocks)
8. All tests pass: `cargo test --quiet`
</verification>

<success_criteria>
1. PathSummary.summary is populated (not None) for all paths
2. Summaries are human-readable: "entry → validate → return (3 blocks)"
3. Error paths include "→ error" in description
4. Long paths (>5 blocks) show truncation with "..."
5. LLMs can use summary field for quick path understanding
6. No external dependencies (template-based generation)
</success_criteria>

<output>
After completion, create `.planning/phases/07-llm-integration/07-04-SUMMARY.md`
</output>
