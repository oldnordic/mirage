---
phase: 07-llm-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [src/cli/mod.rs, src/cfg/source.rs]
autonomous: true

must_haves:
  truths:
    - "Path results include block sequence and source locations"
    - "LLM can map each block to file:line:column for navigation"
  artifacts:
    - path: "src/cli/mod.rs"
      provides: "PathSummary with source locations"
      min_lines: 50
      contains: ["source_range", "PathSummary::from_with_cfg"]
    - path: "src/cfg/source.rs"
      provides: "SourceLocation serialization already in place"
      exports: ["SourceLocation"]
  key_links:
    - from: "PathSummary::from_with_cfg"
      to: "BasicBlock.source_location"
      via: "cfg[block_id].source_location.clone()"
      pattern: "source_location.*cfg.*block_id"
    - from: "PathBlock.terminator"
      to: "BasicBlock.terminator"
      via: "format!(\"{:?}\", cfg[block_id].terminator)"
      pattern: "terminator.*format.*"
---

<objective>
Source location inclusion in path output

Purpose: Enable LLMs to map CFG blocks back to source code locations. Currently, `PathBlock` contains only `block_id` and a placeholder "Unknown" terminator. This plan integrates source location data from the CFG so agents can navigate to exact file positions.

Output: `PathSummary` with populated `source_range` and `PathBlock.terminator` derived from CFG's `BasicBlock` data.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-llm-integration/07-RESEARCH.md
@src/cli/mod.rs
@src/cfg/mod.rs
@src/cfg/source.rs
@src/output/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Add From implementation with CFG access</name>
  <files>src/cli/mod.rs</files>
  <action>
    Add a new method to `PathSummary` that accepts both `Path` and `&Cfg`:

    ```rust
    impl PathSummary {
        /// Create PathSummary with CFG data for source locations
        pub fn from_with_cfg(path: crate::cfg::Path, cfg: &crate::cfg::Cfg) -> Self {
            use crate::cfg::NodeIndex;
            use petgraph::graph::NodeIndex;

            // Build PathBlock list with source locations
            let blocks: Vec<PathBlock> = path.blocks.iter().map(|&block_id| {
                // Find the node in the CFG
                let node_idx = cfg.node_indices()
                    .find(|&n| cfg[n].id == block_id);

                let terminator = match node_idx {
                    Some(idx) => format!("{:?}", cfg[idx].terminator),
                    None => "Unknown".to_string(),
                };

                PathBlock {
                    block_id,
                    terminator,
                }
            }).collect();

            // Calculate source range from first and last blocks
            let source_range = Self::calculate_source_range(&path, cfg);

            let length = path.len();

            Self {
                path_id: path.path_id,
                kind: format!("{:?}", path.kind),
                length,
                summary: None,  // Filled in plan 07-04
                source_range,
                blocks,
            }
        }

        /// Calculate overall source range for a path
        fn calculate_source_range(path: &crate::cfg::Path, cfg: &crate::cfg::Cfg) -> Option<SourceRange> {
            use petgraph::graph::NodeIndex;

            let first_loc = path.blocks.first()
                .and_then(|&bid| cfg.node_indices().find(|&n| cfg[n].id == bid))
                .and_then(|idx| cfg[idx].source_location.clone());

            let last_loc = path.blocks.last()
                .and_then(|&bid| cfg.node_indices().find(|&n| cfg[n].id == bid))
                .and_then(|idx| cfg[idx].source_location.clone());

            match (first_loc, last_loc) {
                (Some(first), Some(last)) => {
                    // Use first file_path, combine line ranges
                    Some(SourceRange {
                        file_path: first.file_path.to_string_lossy().to_string(),
                        start_line: first.start_line,
                        end_line: last.end_line,
                    })
                }
                _ => None,
            }
        }
    }
    ```

    Place this impl block after the existing `impl From<crate::cfg::Path> for PathSummary`.
  </action>
  <verify>
    grep -n "from_with_cfg\|calculate_source_range" src/cli/mod.rs
  </verify>
  <done>PathSummary::from_with_cfg method creates PathBlocks with terminator and calculates source_range</done>
</task>

<task type="auto">
  <name>Update paths() command to use from_with_cfg</name>
  <files>src/cli/mod.rs</files>
  <action>
    In the `paths()` function (around line 435 and 447), replace:

    ```rust
    paths: paths.into_iter().map(PathSummary::from).collect(),
    ```

    With:

    ```rust
    paths: paths.iter().map(|p| PathSummary::from_with_cfg(p.clone(), &cfg)).collect(),
    ```

    Note: We need to iterate by reference (not into_iter) because `from_with_cfg` borrows the CFG.

    There are two locations - one for `OutputFormat::Json` and one for `OutputFormat::Pretty`. Update both.
  </action>
  <verify>
    grep -n "from_with_cfg" src/cli/mod.rs | wc -l  # Should be 2 (json + pretty)
  </verify>
  <done>Both JSON and Pretty output paths use from_with_cfg for source location data</done>
</task>

<task type="auto">
  <name>Verify source location serialization</name>
  <files>src/cfg/source.rs, src/cli/mod.rs</files>
  <action>
    The `SourceLocation` struct already derives `Serialize` (line 7 of source.rs), so JSON output should work.

    However, verify `PathBuf` serialization works correctly. In `SourceRange`, we use `String` instead of `PathBuf` because `PathBuf` doesn't serialize cleanly to JSON in all cases.

    Check that `SourceRange.file_path` is `String` type (already done in plan 07-01).

    Run tests:
    ```bash
    cargo test --quiet 2>&1 | grep -E "(test result:|error\[)"
    ```
  </action>
  <verify>
    cargo build --quiet 2>&1
    ./target/debug/mirage paths --function test --output json | jq '.data.paths[0].source_range'
  </verify>
  <done>SourceRange serializes correctly, JSON output includes file_path and line range</done>
</task>

</tasks>

<verification>
1. Compile succeeds: `cargo check --quiet`
2. All existing tests pass: `cargo test --quiet`
3. JSON output includes source_range: `mirage paths --function test --output json` shows source_range with file_path, start_line, end_line
4. PathBlock.terminator shows actual terminator types (Goto, Return, etc.) not "Unknown"
5. When source_location is None (AST-based CFG), source_range is null in JSON
</verification>

<success_criteria>
1. PathSummary.source_range populated when CFG blocks have source locations
2. PathBlock.terminator shows actual terminator type from CFG
3. JSON output includes file_path, start_line, end_line in source_range
4. Graceful handling when source_location is None (source_range = null)
5. LLMs can map each block back to source file and line number
</success_criteria>

<output>
After completion, create `.planning/phases/07-llm-integration/07-02-SUMMARY.md`
</output>
