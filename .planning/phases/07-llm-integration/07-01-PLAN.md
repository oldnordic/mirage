---
phase: 07-llm-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/cli/mod.rs]
autonomous: true

must_haves:
  truths:
    - "Path queries return structured JSON with path IDs"
    - "LLM can parse and use path data without ambiguity"
  artifacts:
    - path: "src/cli/mod.rs"
      provides: "LLM-optimized response structs"
      min_lines: 100
      contains: ["PathBlock", "SourceRange", "PathSummary"]
  key_links:
    - from: "paths() command"
      to: "PathsResponse struct"
      via: "serde::Serialize"
      pattern: "PathsResponse.*function.*total_paths.*paths"
    - from: "PathSummary::from(Path)"
      to: "PathSummary with blocks"
      via: "impl From<crate::cfg::Path> for PathSummary"
      pattern: "impl From.*Path.*for PathSummary"
---

<objective>
Enhanced JSON output format for LLM consumption

Purpose: Extend the path query JSON output with structured block-level information that LLMs can parse and reason about. The current `PathSummary` only includes raw block IDs (`Vec<usize>`), which lacks context for agents to understand source locations.

Output: `PathSummary` extended with `PathBlock` structs containing block IDs and metadata, wrapped in `PathsResponse` with consistent schema version.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-llm-integration/07-RESEARCH.md
@src/cli/mod.rs
@src/cfg/mod.rs
@src/output/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Add LLM-optimized response structs to CLI module</name>
  <files>src/cli/mod.rs</files>
  <action>
    Add new structs before the existing `PathSummary` definition (around line 228):

    1. Add `PathBlock` struct:
       ```rust
       #[derive(serde::Serialize)]
       struct PathBlock {
           block_id: usize,
           terminator: String,  // String representation of Terminator enum
       }
       ```

    2. Add `SourceRange` struct:
       ```rust
       #[derive(serde::Serialize)]
       struct SourceRange {
           file_path: String,  // Use String, not PathBuf, for JSON serialization
           start_line: usize,
           end_line: usize,
       }
       ```

    3. Update `PathSummary` to use new structs:
       - Change `blocks: Vec<usize>` to `blocks: Vec<PathBlock>`
       - Add `summary: Option<String>` field (populate with None for now, filled in plan 07-04)
       - Add `source_range: Option<SourceRange>` field (populate with None for now, filled in plan 07-02)

    Do NOT add `#[serde(skip_serializing_if = "Option::is_none")]` - we want nulls to be explicit for LLMs.
  </action>
  <verify>
    grep -n "struct PathBlock\|struct SourceRange\|struct PathSummary" src/cli/mod.rs
  </verify>
  <done>PathBlock and SourceRange structs defined, PathSummary updated with new fields</done>
</task>

<task type="auto">
  <name>Update PathSummary::from implementation</name>
  <files>src/cli/mod.rs</files>
  <action>
    Update the `impl From<crate::cfg::Path> for PathSummary` implementation (around line 235):

    Current implementation:
    ```rust
    fn from(path: crate::cfg::Path) -> Self {
        let length = path.len();
        Self {
            path_id: path.path_id,
            kind: format!("{:?}", path.kind),
            length,
            blocks: path.blocks,
        }
    }
    ```

    New implementation must:
    1. Create `Vec<PathBlock>` from `path.blocks` with `block_id` and `terminator` set to "Unknown" (source location comes in plan 07-02)
    2. Set `summary` to `None` (filled in plan 07-04)
    3. Set `source_range` to `None` (filled in plan 07-02)

    For the terminator field, use a placeholder "Unknown" string since we don't have CFG access in this conversion. The full terminator info will be added when source locations are integrated in plan 07-02.
  </action>
  <verify>
    cargo check --quiet 2>&1 | head -20
  </verify>
  <done>PathSummary::from creates PathBlock structs, compilation succeeds</done>
</task>

<task type="auto">
  <name>Verify JSON output structure</name>
  <files>src/cli/mod.rs</files>
  <action>
    Run the existing CLI test to verify JSON output still works:

    ```bash
    cargo test paths_json_output --quiet
    ```

    If the test doesn't exist or fails, run a manual check:
    ```bash
    cargo build --quiet
    ./target/debug/mirage paths --function test --output json | head -30
    ```

    Verify the JSON contains:
    - `schema_version: "1.0.0"`
    - `tool: "mirage"`
    - `execution_id` (timestamp-process_id format)
    - `data.paths[].blocks[]` with `block_id` and `terminator` fields
  </action>
  <verify>
    ./target/debug/mirage paths --function test --output json 2>&1 | jq '.data.paths[0].blocks[0]' | grep -q "block_id"
  </verify>
  <done>JSON output includes PathBlock array with block_id and terminator fields</done>
</task>

</tasks>

<verification>
1. Compile succeeds: `cargo check --quiet`
2. All existing tests pass: `cargo test --quiet`
3. JSON output contains new structure: `mirage paths --function test --output json` shows blocks as array of objects
4. JsonResponse wrapper metadata intact: schema_version, tool, execution_id, timestamp
</verification>

<success_criteria>
1. PathSummary includes blocks as Vec<PathBlock> instead of Vec<usize>
2. PathBlock struct contains block_id (usize) and terminator (String) fields
3. SourceRange struct defined with file_path, start_line, end_line
4. JSON serialization works without errors
5. LLMs can parse path data with explicit field names (not just bare integers)
</success_criteria>

<output>
After completion, create `.planning/phases/07-llm-integration/07-01-SUMMARY.md`
</output>
