---
phase: 01-database-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/cli/mod.rs
  - src/storage/mod.rs
autonomous: true

must_haves:
  truths:
    - "`mirage status` command shows database statistics"
    - "Database path is correctly resolved from --db flag or env var"
    - "Status output includes counts for cfg_blocks, cfg_edges, cfg_paths, cfg_dominators"
  artifacts:
    - path: "src/cli/mod.rs"
      provides: "Status command wired to database"
      exports: ["cmds::status"]
    - path: "src/storage/mod.rs"
      provides: "DatabaseStatus query implementation"
      contains: "MirageDb::status"
  key_links:
    - from: "cli::cmds::status"
      to: "MirageDb::status"
      via: "Function call to query database statistics"
      pattern: "MirageDb::open\\(\\).*\\.status\\(\\)"
---

<objective>
Wire up the status command to display database statistics

Purpose: Enable users to verify Mirage database state and see analysis progress.
This supports CLI-11 requirement.

Output: Working `mirage status` command that shows all table counts.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@src/storage/mod.rs
@src/cli/mod.rs
@.planning/phases/01-database-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement database path resolution utility</name>
  <files>src/cli/mod.rs</files>
  <action>
    Add a utility function to resolve the database path from multiple sources:

    1. Add function in cli module:
       ```rust
       pub fn resolve_db_path(cli_db: Option<String>) -> Result<String> {
           // Priority: CLI arg > MIRAGE_DB env var > default "./codemcp.db"
           match cli_db {
               Some(path) => Ok(path),
               None => std::env::var("MIRAGE_DB")
                   .or_else(|_| Ok("./codemcp.db".to_string())),
           }
       }
       ```

    2. This follows Magellan's pattern for database path resolution.
  </action>
  <verify>
    Add unit test that verifies resolution priority:
    - No arg, no env -> returns default
    - Env var set -> returns env var value
    - CLI arg provided -> returns CLI arg (overrides env)
  </verify>
  <done>Database path is correctly resolved from CLI arg, env var, or default</done>
</task>

<task type="auto">
  <name>Task 2: Wire status command to DatabaseStatus</name>
  <files>src/cli/mod.rs</files>
  <action>
    Implement the status command handler:

    1. Modify `cmds::status()` to:
       a. Call `resolve_db_path(args.db)` to get database path
       b. Open database with `MirageDb::open(path)`
       c. Call `db.status()` to get statistics
       d. Format and output results using output module

    2. Output format should match Magellan's style:
       ```
       Mirage Database Status:
         Schema version: 1 (Magellan: 4)
         cfg_blocks: 42
         cfg_edges: 87
         cfg_paths: 15
         cfg_dominators: 42
       ```

    3. Handle errors gracefully:
       - Database not found -> clear error message suggesting `mirage index`
       - Schema version mismatch -> clear error with upgrade suggestion

    Use `output::info()` for status output, `output::error()` for errors.
  </action>
  <verify>
    1. Create a test Mirage database with known data
    2. Run `cargo run -- status --db test.db`
    3. Verify output shows correct counts
    4. Run with non-existent database -> verify error message
  </verify>
  <done>Status command displays database statistics with proper error handling</done>
</task>

<task type="auto">
  <name>Task 3: Add JSON and pretty output formats for status</name>
  <files>src/cli/mod.rs</files>
  <action>
    Implement structured output formats for status command (CLI-12 requirement):

    1. For `--output json`: serialize DatabaseStatus to compact JSON
    2. For `--output pretty`: serialize DatabaseStatus to indented JSON
    3. For `--output human` (default): use existing text format

    Use serde_json for serialization. The DatabaseStatus struct already derives
    Serialize, so just need to call serde_json::to_string() or to_string_pretty().

    Add output format handling based on cli.output field (already defined in Cli struct).
  </action>
  <verify>
    Run:
    - `mirage status --output human` (text output)
    - `mirage status --output json` (compact JSON)
    - `mirage status --output pretty` (indented JSON)

    Verify each format is correct and parseable.
  </verify>
  <done>Status command supports all three output formats (human, json, pretty)</done>
</task>

</tasks>

<verification>
Overall phase verification:
1. Run `cargo run -- status` -> shows stats from default database
2. Run `cargo run -- status --db /path/to/db` -> shows stats from specified database
3. Run `cargo run -- status --output json` -> valid JSON output
4. Run with non-existent database -> clear error message
5. Run `cargo test` -> all tests pass
</verification>

<success_criteria>
1. `mirage status` displays cfg_blocks, cfg_edges, cfg_paths, cfg_dominators counts
2. Database path resolution follows Magellan conventions
3. All output formats (human, json, pretty) work correctly
4. Error messages are clear and actionable
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-foundation/01-02-SUMMARY.md` with:
- Status command implementation details
- Output format examples
- Any edge cases handled
</output>
