---
phase: 09-mir-integration-database-loading
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/mod.rs
  - src/mir/charon.rs
  - src/storage/mod.rs
autonomous: false

user_setup:
  - service: charon
    why: "MIR extraction for Rust projects"
    env_vars: []
    dashboard_config:
      - task: "Install Charon binary"
        location: "https://github.com/AeneasVerif/charon"
        notes: "cargo install charon or download from releases"

must_haves:
  truths:
    - "mirage index --project PATH runs Charon and extracts ULLBC JSON"
    - "Parsed ULLBC functions are converted to CFGs using existing ullbc_to_cfg()"
    - "CFGs are stored in cfg_blocks table with function_hash for incremental updates"
    - "progress indication shown during indexing (functions processed, errors encountered)"
  artifacts:
    - path: "src/cli/mod.rs"
      provides: "index() command implementation"
      exports: ["index()"]
      min_lines: 80
    - path: "src/storage/mod.rs"
      provides: "CFG storage functions"
      exports: ["store_cfg()", "function_exists()"]
      min_lines: 60
  key_links:
    - from: "src/cli/mod.rs::index()"
      to: "src/mir/charon.rs::run_charon()"
      via: "spawns charon binary and captures JSON output"
      pattern: "run_charon"
    - from: "src/cli/mod.rs::index()"
      to: "src/cfg/mir.rs::ullbc_to_cfg()"
      via: "converts parsed ULLBC to CFG"
      pattern: "ullbc_to_cfg"
    - from: "src/cli/mod.rs::index()"
      to: "src/storage/mod.rs::store_cfg()"
      via: "stores CFG in database"
      pattern: "store_cfg"
---

<objective>
Implement `mirage index` command for MIR extraction via Charon, storing CFGs in database with incremental update support.

Purpose: Enable Mirage to extract accurate Rust CFGs using Charon ULLBC output, providing the foundation for all database-dependent analysis features.

Output: Working `mirage index` command that extracts MIR, stores CFGs, and supports incremental updates.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cfg-construction/02-01-SUMMARY.md
@src/mir/charon.rs
@src/cfg/mir.rs
@src/storage/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CFG storage in database</name>
  <files>src/storage/mod.rs</files>
  <action>
    Add the following functions to src/storage/mod.rs:

    1. store_cfg(conn, function_id, function_hash, cfg) - stores a CFG in the database:
       - Clear existing cfg_blocks for this function_id (for incremental updates)
       - Insert each BasicBlock as a row in cfg_blocks:
         * id: auto-increment
         * function_id: from parameter
         * block_kind: Entry/Normal/Exit as string
         * byte_start/byte_end: from source_location if available
         * terminator: serialized as JSON string
         * function_hash: for incremental invalidation
       - Insert each edge as a row in cfg_edges:
         * from_id: database row id of source block
         * to_id: database row id of target block
         * edge_type: Fallthrough/TrueBranch/FalseBranch/Call/Exception as string

    2. function_exists(conn, function_id) -> bool - checks if function is already indexed

    3. get_function_hash(conn, function_id) -> Option<String> - retrieves stored hash for comparison

    Use prepared statements with BEGIN IMMEDIATE TRANSACTION for atomicity.
    Return Result<()> with anyhow error context.
  </action>
  <verify>cargo test passes, manual test with test CFG stores and retrieves blocks</verify>
  <done>CFG can be stored and retrieved from database with all blocks and edges</done>
</task>

<task type="auto">
  <name>Task 2: Implement index() command with Charon integration</name>
  <files>src/cli/mod.rs</files>
  <action>
    Replace the stub index() function (around line 535) with full implementation:

    1. Resolve database path using resolve_db_path()
    2. Open or create MirageDb (follow status command pattern for error handling)
    3. Determine project path:
       - If --project specified: use that path
       - If --crate specified: find Cargo.toml and use parent directory
       - Default: current directory
    4. Verify Cargo.toml exists (error if not found)
    5. Run Charon: call run_charon() from mir::charon module
    6. Parse ULLBC JSON: call parse_ullbc()
    7. For each function in ULLBC:
       a. Compute function_hash (BLAKE3 of function body for incremental detection)
       b. If --incremental and hash matches existing: skip
       c. Convert ULLBC body to CFG using ullbc_to_cfg()
       d. Find or create graph_entities entry for the function
       e. Store CFG using store_cfg()
       f. Print progress indicator (function name, blocks stored)
    8. Print summary: total functions processed, updated, skipped, errors

    Error handling:
    - Charon not found: helpful error with installation link
    - No functions found: warn user
    - Parse errors: skip function, log error, continue processing

    Follow established CLI patterns for JSON output (if --output json|pretty, return JsonResponse with IndexResult struct).
  </action>
  <verify>cargo build succeeds, can run mirage index on a Rust project</verify>
  <done>mirage index successfully indexes a Rust project and stores CFGs in database</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete mirage index command (MIR extraction + database storage)</what-built>
  <how-to-verify>
    1. Ensure Charon is installed: `charon --version`
    2. Run on a test Rust project: `mirage index --project .`
    3. Verify output shows functions processed
    4. Run `mirage status` to confirm cfg_blocks count > 0
    5. Run again with --incremental to verify functions are skipped
    6. Modify a function and run with --incremental to verify re-indexing
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
- cargo build --release succeeds
- mirage index --project PATH completes without errors
- mirage status shows non-zero cfg_blocks count after indexing
- --incremental flag skips unchanged functions
- Charon installation error message is helpful when binary not found
</verification>

<success_criteria>
- mirage index command successfully extracts MIR via Charon
- CFGs stored in cfg_blocks table with proper function_id foreign keys
- function_hash computed and stored for incremental update detection
- Incremental mode skips unchanged functions
- Progress indication shows functions processed, updated, skipped, errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-mir-integration-database-loading/09-01-SUMMARY.md`
</output>
