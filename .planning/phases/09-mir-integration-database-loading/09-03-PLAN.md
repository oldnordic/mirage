---
phase: 09-mir-integration-database-loading
plan: 03
type: execute
wave: 2
depends_on: [09-01, 09-02]
files_modified:
  - src/cli/mod.rs
autonomous: true

must_haves:
  truths:
    - "paths() command loads CFG from database using args.function"
    - "cfg() command loads CFG from database using args.function"
    - "dominators() command loads CFG from database using args.function"
    - "loops() command loads CFG from database using args.function"
    - "patterns() command loads CFG from database using args.function"
    - "frontiers() command loads CFG from database using args.function"
    - "Error handling directs users to run 'mirage index' if function not found"
  artifacts:
    - path: "src/cli/mod.rs"
      provides: "CLI commands with database loading"
      contains: "resolve_function_name|load_cfg_from_db"
      min_lines_modified: 42 (7 TODOs replaced)
  key_links:
    - from: "paths(), cfg(), dominators(), loops(), patterns(), frontiers()"
      to: "resolve_function_name(), load_cfg_from_db()"
      via: "database queries instead of create_test_cfg()"
      pattern: "resolve_function_name.*load_cfg_from_db"
---

<objective>
Wire database loading to all analysis commands, replacing create_test_cfg() placeholders.

Purpose: Enable all CLI commands to work on real indexed code instead of test data.

Output: All 7 analysis commands load CFGs from database using function name/ID.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-mir-integration-database-loading/09-01-SUMMARY.md
@.planning/phases/09-mir-integration-database-loading/09-02-SUMMARY.md
@src/cli/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace create_test_cfg() with database loading in all commands</name>
  <files>src/cli/mod.rs</files>
  <action>
    For each of the following CLI command functions, replace the create_test_cfg() pattern with database loading:

    1. paths() (around line 622):
       - After database connection, call: let function_id = resolve_function_name(&mut db, &args.function)?
       - Replace: let cfg = create_test_cfg();
       - With: let cfg = load_cfg_from_db(&mut db, function_id)?;
       - Update test_function_hash from "test_cfg" to use actual hash from database

    2. cfg() (around line 736):
       - Same pattern as paths(): resolve function_id, then load_cfg_from_db()

    3. dominators() (around line 846):
       - Same pattern: resolve and load

    4. loops() (around line 1172):
       - Same pattern: resolve and load

    5. patterns() (around line 1558):
       - Same pattern: resolve and load

    6. frontiers() (around line 1688):
       - Same pattern: resolve and load

    7. unreachable() (around line 1264):
       - For --within-functions mode: load all functions and process each
       - For single function: resolve and load specific function

    Error handling pattern (established in status command):
    ```rust
    let function_id = match resolve_function_name(&mut db, &args.function) {
        Ok(id) => id,
        Err(e) => {
            if matches!(cli.output, OutputFormat::Json | OutputFormat::Pretty) {
                let error = output::JsonError::new("E004", &format!("Function '{}' not found. Run 'mirage index' first.", args.function));
                println!("{}", output::JsonResponse::new(error).to_json());
            } else {
                output::error(&format!("Function '{}' not found in database", args.function));
                output::info("Hint: Run 'mirage index' to index your code");
            }
            std::process::exit(output::EXIT_DATABASE);
        }
    };
    ```

    Import required functions at top of cmds module:
    - use crate::storage::{resolve_function_name, load_cfg_from_db};

    Update tests:
    - Tests that use create_test_cfg() can keep using it for test data
    - Add new tests for database loading path
  </action>
  <verify>cargo build succeeds, all CLI commands work with indexed functions</verify>
  <done>All 7 commands load from database instead of using test CFGs</done>
</task>

<task type="auto">
  <name>Task 2: Update unreachable() command for database-backed function listing</name>
  <files>src/cli/mod.rs</files>
  <action>
    Update unreachable() command (around line 1264) to support real database queries:

    1. If --within-functions flag is set:
       - Query all functions from graph_entities where kind = 'function'
       - For each function: load CFG, find unreachable blocks
       - Aggregate results with function names

    2. If --within-functions is NOT set (default):
       - Resolve single function from args.function
       - Load CFG for that function
       - Find and display unreachable blocks

    3. Update UnreachableResponse struct to include:
       - functions_with_unreachable: list of function names with unreachable blocks
       - total_functions: total functions scanned (in --within-functions mode)

    4. Error handling:
       - If no functions found, show helpful message
       - If function has no unreachable blocks, indicate this clearly

    Follow the JSON-aware error pattern established in other commands.
  </action>
  <verify>cargo test cli::cmds::tests::unreachable passes</verify>
  <done>unreachable() command lists all functions or processes single function from database</done>
</task>

</tasks>

<verification>
- cargo build --release succeeds
- All 7 commands work with --function flag on indexed code
- Error messages direct users to run 'mirage index' when function not found
- Tests pass (tests can still use create_test_cfg() for isolation)
</verification>

<success_criteria>
- paths(), cfg(), dominators(), loops(), patterns(), frontiers(), unreachable() all load from database
- Error handling provides helpful hints to run 'mirage index'
- Tests maintain backward compatibility with test CFGs
</success_criteria>

<output>
After completion, create `.planning/phases/09-mir-integration-database-loading/09-03-SUMMARY.md`
</output>
