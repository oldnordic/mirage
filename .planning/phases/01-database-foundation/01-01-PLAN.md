---
phase: 01-database-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/mod.rs
autonomous: true

must_haves:
  truths:
    - "function_hash column enables incremental updates on cfg_blocks table"
    - "Migration framework handles schema version upgrades via mirage_meta table"
    - "Foreign key constraint cfg_blocks.function_id -> graph_entities.id is validated"
  artifacts:
    - path: "src/storage/mod.rs"
      provides: "Enhanced schema with function_hash and migration framework"
      contains: "create_schema", "migrate_schema"
    - path: "cfg_blocks table schema"
      provides: "Function hash tracking for incremental updates"
      contains: "function_hash"
    - path: "mirage_meta table schema"
      provides: "Schema version tracking"
      contains: "mirage_schema_version"
  key_links:
    - from: "cfg_blocks.function_hash"
      to: "incremental update detection"
      via: "Hash comparison on indexing"
      pattern: "function_hash.*INDEX"
    - from: "migrate_schema"
      to: "mirage_meta.mirage_schema_version"
      via: "Version check and upgrade"
      pattern: "migrate_schema.*mirage_schema_version"
    - from: "cfg_blocks.function_id"
      to: "graph_entities.id"
      via: "FOREIGN KEY constraint (existing, validated by test)"
      pattern: "FOREIGN KEY \\(function_id\\) REFERENCES graph_entities\\(id\\)"
---

<objective>
Add incremental update tracking and migration framework to database schema

Purpose: Enable function-level re-analysis when code changes (DB-06) and provide
framework for future schema migrations.

Output: Enhanced schema with function_hash tracking and migration support.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/research/SUMMARY.md
@src/storage/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add function hash tracking for incremental updates</name>
  <files>src/storage/mod.rs</files>
  <action>
    Add a function_hash column to cfg_blocks table to track source code changes:

    1. Modify the CREATE TABLE cfg_blocks statement in create_schema() function
       (around lines 106-117) to add the function_hash column:

       Change:
       ```sql
       CREATE TABLE IF NOT EXISTS cfg_blocks (
           id INTEGER PRIMARY KEY AUTOINCREMENT,
           function_id INTEGER NOT NULL,
           block_kind TEXT NOT NULL,
           ...
       ```

       To:
       ```sql
       CREATE TABLE IF NOT EXISTS cfg_blocks (
           id INTEGER PRIMARY KEY AUTOINCREMENT,
           function_id INTEGER NOT NULL,
           block_kind TEXT NOT NULL,
           byte_start INTEGER,
           byte_end INTEGER,
           terminator TEXT,
           function_hash TEXT,
           FOREIGN KEY (function_id) REFERENCES graph_entities(id)
       )
       ```

    2. After the CREATE TABLE statement, add the index:
       ```sql
       CREATE INDEX IF NOT EXISTS idx_cfg_blocks_function_hash
       ON cfg_blocks(function_hash);
       ```

    This enables DB-06 (incremental updates): when indexing, compare function_hash
    to determine if re-analysis is needed.
  </action>
  <verify>
    Run `cargo test test_create_schema` and verify new column exists via:
    ```bash
    sqlite3 test.db ".schema cfg_blocks" | grep function_hash
    ```
  </verify>
  <done>cfg_blocks table has function_hash column with index for incremental update detection</done>
</task>

<task type="auto">
  <name>Task 2: Add migration framework for schema version upgrades</name>
  <files>src/storage/mod.rs</files>
  <action>
    Create a migration system to handle schema version upgrades:

    1. Add a `migrate_schema(conn: &mut Connection) -> Result<()>` function that:
       - Reads current mirage_schema_version from mirage_meta
       - Applies migrations in sequence for each version bump
       - Updates mirage_schema_version after successful migration

    2. Define migrations as a struct or enum:
       ```rust
       struct Migration {
           version: i32,
           description: &'static str,
           up: fn(&mut Connection) -> Result<()>,
       }
       ```

    3. Modify `MirageDb::open()` to call `migrate_schema()` after verification if
       mirage_version < MIRAGE_SCHEMA_VERSION

    Start with no-op migrations (framework only). Actual migrations will be added
    when schema changes in future phases.
  </action>
  <verify>
    - Create a test database with version 0 (no mirage_meta)
    - Run `MirageDb::open()` and verify mirage_meta is created with version 1
    - Create a test database with version 1
    - Run `MirageDb::open()` and verify no migration occurs (version already current)
  </verify>
  <done>Migration framework exists and can upgrade from older schema versions</done>
</task>

<task type="auto">
  <name>Task 3: Verify existing foreign key constraint behavior</name>
  <files>src/storage/mod.rs</files>
  <action>
    Add a test that verifies the existing foreign key constraint works correctly:

    1. Add test `test_fk_constraint_cfg_blocks` that:
       - Creates a Magellan database with graph_entities entry
       - Attempts to insert cfg_blocks with invalid function_id (no matching graph_entities.id)
       - Verifies the insert fails with foreign key constraint error
       - Inserts valid cfg_blocks with correct function_id
       - Verifies the insert succeeds

    2. Note: The FK constraint already exists in create_schema() at line 114:
       `FOREIGN KEY (function_id) REFERENCES graph_entities(id)`
       This test validates that the existing constraint is properly enforced.

    This proves DB-05: cfg_blocks.function_id correctly foreign keys to graph_entities.id
  </action>
  <verify>Run `cargo test test_fk_constraint_cfg_blocks`</verify>
  <done>Foreign key constraint from cfg_blocks.function_id to graph_entities.id is enforced</done>
</task>

</tasks>

<verification>
Overall phase verification:
1. Run `cargo test` - all tests pass
2. Inspect schema: `sqlite3 test.db ".schema cfg_blocks"` shows function_hash column
3. Verify foreign keys: `sqlite3 test.db "PRAGMA foreign_keys;"`
4. Check function_hash column exists: `sqlite3 test.db "PRAGMA table_info(cfg_blocks);" | grep hash`
5. Verify migration framework: `sqlite3 test.db "SELECT * FROM mirage_meta WHERE key = 'mirage_schema_version';"`
</verification>

<success_criteria>
1. function_hash column added to cfg_blocks table for incremental update detection
2. Migration framework handles schema version upgrades
3. Foreign key constraint from cfg_blocks.function_id to graph_entities.id validated by test
4. Schema version tracking in mirage_meta table
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-foundation/01-01-SUMMARY.md` with:
- Actual schema changes made
- Test coverage added
- Any issues encountered
</output>
