---
phase: 10-magellan-v2-integration-and-bugfixes
plan: 05
type: execute
wave: 4
depends_on: ["10-01", "10-02", "10-03"]
files_modified:
  - src/analysis/mod.rs
  - src/cli/mod.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "slice command performs backward/forward program slicing"
    - "MagellanBridge has backward_slice and forward_slice methods"
    - "CLI slice command integrates with Magellan slicing algorithm"
  artifacts:
    - path: "src/analysis/mod.rs"
      provides: "Program slicing via Magellan's slice algorithm"
      exports: ["SliceWrapper", "MagellanBridge::backward_slice", "MagellanBridge::forward_slice"]
    - path: "src/cli/mod.rs"
      contains: "new slice command with --direction flag"
  key_links:
    - from: "src/cli/mod.rs"
      to: "src/analysis/mod.rs"
      via: "MagellanBridge::backward_slice() or forward_slice()"
      pattern: "(backward|forward)_slice"
---

<objective>
Add a slice command that uses Magellan's program slicing algorithm to find what affects a symbol (backward slice) or what a symbol affects (forward slice).

Purpose: Enable precise impact analysis - show the set of code that influences a target variable/function (backward) or is influenced by it (forward).

Output: New slice command with --direction flag performing program slicing.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-magellan-v2-integration-and-bugfixes/10-RESEARCH.md
@.planning/phases/10-magellan-v2-integration-and-bugfixes/10-01-SUMMARY.md

# Magellan slicing API
magellan::CodeGraph has backward_slice() and forward_slice() methods
Returns ProgramSlice with included_symbols and statistics
Uses call-graph fallback (CFG-based slicing is future enhancement)
</context>

<tasks>

<task type="auto">
  <name>Add program slicing wrappers to MagellanBridge</name>
  <files>src/analysis/mod.rs</files>
  <action>
  Add to src/analysis/mod.rs:

  1. Add SliceWrapper response struct:
     ```rust
     use magellan::{ProgramSlice, SliceDirection, SliceResult};

     #[derive(Debug, Clone, serde::Serialize)]
     pub struct SliceWrapper {
         /// Target symbol for the slice
         pub target: SymbolInfo,
         /// Direction of slicing
         pub direction: String,  // "backward" or "forward"
         /// Symbols included in the slice
         pub included_symbols: Vec<SymbolInfo>,
         /// Number of symbols in the slice
         pub symbol_count: usize,
         /// Statistics about the slice
         pub statistics: SliceStats,
     }

     #[derive(Debug, Clone, serde::Serialize)]
     pub struct SliceStats {
         pub total_symbols: usize,
         pub data_dependencies: usize,
         pub control_dependencies: usize,
     }
     ```

  2. Add slicing methods to MagellanBridge:
     ```rust
     impl MagellanBridge {
         /// Backward slice: What affects this symbol?
         ///
         /// Finds all symbols that can influence the target via data/control flow.
         pub fn backward_slice(&self, symbol_id_or_fqn: &str) -> Result<SliceWrapper> {
             let result = self.graph.backward_slice(symbol_id_or_fqn)?;
             Ok(Self::wrap_slice_result(result))
         }

         /// Forward slice: What does this symbol affect?
         ///
         /// Finds all symbols influenced by the target via data/control flow.
         pub fn forward_slice(&self, symbol_id_or_fqn: &str) -> Result<SliceWrapper> {
             let result = self.graph.forward_slice(symbol_id_or_fqn)?;
             Ok(Self::wrap_slice_result(result))
         }

         fn wrap_slice_result(result: SliceResult) -> SliceWrapper {
             let statistics = SliceStats {
                 total_symbols: result.slice.symbol_count,
                 data_dependencies: result.statistics.data_dependencies,
                 control_dependencies: result.statistics.control_dependencies,
             };

             SliceWrapper {
                 target: result.slice.target,
                 direction: format!("{:?}", result.slice.direction),
                 included_symbols: result.slice.included_symbols,
                 symbol_count: result.slice.symbol_count,
                 statistics,
             }
         }
     }
     ```

  3. Import SliceResult from magellan::graph::algorithms
  </action>
  <verify>cargo check passes, slice methods compile</verify>
  <done>MagellanBridge has backward_slice and forward_slice methods</done>
</task>

<task type="auto">
  <name>Create slice CLI command</name>
  <files>src/cli/mod.rs</files>
  <action>
  1. Add new Slice command to Commands enum:
     ```rust
     #[derive(Subcommand, Debug, Clone)]
     pub enum Commands {
         // ... existing commands ...

         /// Perform program slicing (backward/forward impact analysis)
         Slice(SliceArgs),
     }
     ```

  2. Add SliceArgs struct:
     ```rust
     #[derive(Parser, Debug, Clone)]
     pub struct SliceArgs {
         /// Symbol ID or FQN to slice
         #[arg(long)]
         pub symbol: String,

         /// Slice direction: backward (what affects) or forward (what affects)
         #[arg(long, value_enum)]
         pub direction: SliceDirectionArg,

         /// Show detailed symbol information
         #[arg(long)]
         pub verbose: bool,
     }

     #[derive(ValueEnum, Debug, Clone, Copy, PartialEq, Eq)]
     pub enum SliceDirectionArg {
         /// Backward: what affects this symbol
         Backward,
         /// Forward: what this symbol affects
         Forward,
     }
     ```

  3. Add slice() command handler:
     - Open MagellanBridge
     - Call backward_slice() or forward_slice() based on direction
     - Format output for human/JSON/pretty
     - Human output shows:
       - Target symbol
       - Direction
       - Count of symbols in slice
       - List of included symbols (verbose)
       - Statistics

  4. Add SliceResponse struct:
     ```rust
     #[derive(serde::Serialize)]
     struct SliceResponse {
         target: SymbolInfo,
         direction: String,
         included_symbols: Vec<SymbolInfo>,
         symbol_count: usize,
         statistics: SliceStats,
     }
     ```

  5. Wire up in main.rs command matcher
  </action>
  <verify>cargo check passes, slice command compiles</verify>
  <done>slice CLI command created and wired</done>
</task>

<task type="auto">
  <name>Test program slicing</name>
  <files>src/analysis/mod.rs</files>
  <action>
  1. Add unit test for MagellanBridge slicing:
     - Create test call graph: main -> func_a -> func_b
     - Test backward_slice("func_b") includes [main, func_a, func_b]
     - Test forward_slice("main") includes [main, func_a, func_b]

  2. Integration test for slice command:
     - Create test database with call graph
     - Run slice command with both directions
     - Verify correct symbols are included

  3. Add doctest examples for slice methods
  </action>
  <verify>cargo test passes for slice tests</verify>
  <done>Program slicing tested</done>
</task>

</tasks>

<verification>
1. `mirage slice --symbol foo --direction backward` works
2. `mirage slice --symbol bar --direction forward` works
3. JSON output includes target, direction, included_symbols, statistics
4. Human output shows readable summary
5. All tests pass
</verification>

<success_criteria>
1. New slice command works
2. Both backward and forward directions work
3. Output shows symbols included in slice
4. Statistics are reported (data/control dependencies)
5. Wires correctly in main.rs
</success_criteria>

<output>
After completion, create `.planning/phases/10-magellan-v2-integration-and-bugfixes/10-05-SUMMARY.md`
</output>
