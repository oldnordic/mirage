---
phase: 01-database-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/mod.rs
autonomous: true

must_haves:
  truths:
    - "Database migration creates cfg_blocks, cfg_edges, cfg_paths, cfg_dominators tables in Magellan database"
    - "cfg_blocks.function_id correctly foreign keys to graph_entities.id"
    - "Schema version is tracked for future migrations"
  artifacts:
    - path: "src/storage/mod.rs"
      provides: "Database schema creation and migration framework"
      contains: "create_schema", "migrate_schema"
    - path: "mirage_meta table schema"
      provides: "Schema version tracking"
      contains: "mirage_schema_version"
  key_links:
    - from: "cfg_blocks.function_id"
      to: "graph_entities.id"
      via: "FOREIGN KEY constraint"
      pattern: "FOREIGN KEY \\(function_id\\) REFERENCES graph_entities\\(id\\)"
---

<objective>
Add incremental update tracking and migration framework to database schema

Purpose: Enable function-level re-analysis when code changes (DB-06) and provide
framework for future schema migrations.

Output: Enhanced schema with function_hash tracking and migration support.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/research/SUMMARY.md
@src/storage/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add function hash tracking for incremental updates</name>
  <files>src/storage/mod.rs</files>
  <action>
    Add a function_hash column to cfg_blocks table to track source code changes:

    1. Modify cfg_blocks table schema to include:
       - function_hash TEXT - BLAKE3 hash of function's source code
       - indexed for fast lookup during incremental updates

    2. Add the index:
       ```sql
       CREATE INDEX IF NOT EXISTS idx_cfg_blocks_function_hash
       ON cfg_blocks(function_hash);
       ```

    This enables DB-06 (incremental updates): when indexing, compare function_hash
    to determine if re-analysis is needed.
  </action>
  <verify>
    Run `cargo test test_create_schema` and verify new column exists via:
    ```bash
    sqlite3 test.db ".schema cfg_blocks" | grep function_hash
    ```
  </verify>
  <done>cfg_blocks table has function_hash column with index for incremental update detection</done>
</task>

<task type="auto">
  <name>Task 2: Add migration framework for schema version upgrades</name>
  <files>src/storage/mod.rs</files>
  <action>
    Create a migration system to handle schema version upgrades:

    1. Add a `migrate_schema(conn: &mut Connection) -> Result<()>` function that:
       - Reads current mirage_schema_version from mirage_meta
       - Applies migrations in sequence for each version bump
       - Updates mirage_schema_version after successful migration

    2. Define migrations as a struct or enum:
       ```rust
       struct Migration {
           version: i32,
           description: &'static str,
           up: fn(&mut Connection) -> Result<()>,
       }
       ```

    3. Modify `MirageDb::open()` to call `migrate_schema()` after verification if
       mirage_version < MIRAGE_SCHEMA_VERSION

    Start with no-op migrations (framework only). Actual migrations will be added
    when schema changes in future phases.
  </action>
  <verify>
    - Create a test database with version 0 (no mirage_meta)
    - Run `MirageDb::open()` and verify mirage_meta is created with version 1
    - Create a test database with version 1
    - Run `MirageDb::open()` and verify no migration occurs (version already current)
  </verify>
  <done>Migration framework exists and can upgrade from older schema versions</done>
</task>

<task type="auto">
  <name>Task 3: Add foreign key constraint verification test</name>
  <files>src/storage/mod.rs</files>
  <action>
    Add a test that verifies foreign key constraints work correctly:

    1. Add test `test_fk_constraint_cfg_blocks` that:
       - Creates a Magellan database with graph_entities entry
       - Attempts to insert cfg_blocks with invalid function_id
       - Verifies the insert fails with foreign key constraint error
       - Inserts valid cfg_blocks with correct function_id
       - Verifies the insert succeeds

    2. This proves DB-05: cfg_blocks.function_id correctly foreign keys to graph_entities.id
  </action>
  <verify>Run `cargo test test_fk_constraint_cfg_blocks`</verify>
  <done>Foreign key constraint from cfg_blocks.function_id to graph_entities.id is enforced</done>
</task>

</tasks>

<verification>
Overall phase verification:
1. Run `cargo test` - all tests pass
2. Inspect schema: `sqlite3 test.db ".schema"` shows all cfg_* tables with proper indexes
3. Verify foreign keys: `sqlite3 test.db "PRAGMA foreign_keys;"`
4. Check function_hash column exists: `sqlite3 test.db "PRAGMA table_info(cfg_blocks);" | grep hash`
</verification>

<success_criteria>
1. Database migration creates all required tables in Magellan database
2. cfg_blocks.function_id foreign keys to graph_entities.id (verified by test)
3. Schema version is tracked in mirage_meta table
4. function_hash column enables incremental update detection
5. Migration framework can handle future schema upgrades
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-foundation/01-01-SUMMARY.md` with:
- Actual schema changes made
- Test coverage added
- Any issues encountered
</output>
