---
phase: 09-mir-integration-database-loading
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/storage/mod.rs
  - src/cfg/mod.rs
autonomous: true

must_haves:
  truths:
    - "resolve_function_name() converts function name/ID to function_id"
    - "load_cfg_from_db() reconstructs Cfg from cfg_blocks and cfg_edges"
    - "Utility functions are exported and usable across CLI commands"
  artifacts:
    - path: "src/storage/mod.rs"
      provides: "Function resolution and CFG loading utilities"
      exports: ["resolve_function_name()", "load_cfg_from_db()"]
      min_lines: 80
    - path: "src/cfg/mod.rs"
      provides: "Re-export of database loading functions for convenience"
      exports: ["load_cfg_from_db"]
  key_links:
    - from: "resolve_function_name()"
      to: "graph_entities table"
      via: "queries function by name or ID"
      pattern: "SELECT.*graph_entities.*WHERE"
    - from: "load_cfg_from_db()"
      to: "cfg_blocks, cfg_edges"
      via: "joins blocks and edges to reconstruct Cfg"
      pattern: "cfg_blocks.*cfg_edges"
---

<objective>
Create shared utility functions for resolving function names/IDs and loading CFGs from database.

Purpose: Provide a reusable database loading layer that all CLI commands can use instead of create_test_cfg().

Output: Shared storage utilities for function resolution and CFG reconstruction.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/storage/mod.rs
@src/cfg/mod.rs
@src/cli/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add function resolution and CFG loading utilities</name>
  <files>src/storage/mod.rs</files>
  <action>
    Add the following functions to src/storage/mod.rs after the status() function:

    1. resolve_function_name(conn, name_or_id) -> Result<i64>:
       - If input is numeric (parses as i64): query by id directly
       - Otherwise: query graph_entities for function matching name
         * Query: SELECT id FROM graph_entities WHERE kind = 'function' AND name = ? LIMIT 1
       - Return function_id if found, error if not found

    2. load_cfg_from_db(conn, function_id) -> Result<Cfg>:
       - Query all cfg_blocks for this function_id:
         * SELECT id, block_kind, byte_start, byte_end, terminator FROM cfg_blocks WHERE function_id = ? ORDER BY id ASC
       - For each block: create BasicBlock with:
         * id: sequential index (0, 1, 2...) based on query order
         * kind: parse from string (Entry/Normal/Exit)
         * terminator: deserialize from JSON string (use serde_json::from_str)
         * source_location: None for now (span info can be added later)
         * statements: empty vec! for now
       - Add all blocks to Cfg graph
       - Query all cfg_edges with from_id/to_id mapping:
         * SELECT e.from_id, e.to_id, e.edge_type FROM cfg_edges e
           INNER JOIN cfg_blocks b1 ON e.from_id = b1.id
           INNER JOIN cfg_blocks b2 ON e.to_id = b2.id
           WHERE b1.function_id = ? OR b2.function_id = ?
       - Map database block IDs to graph node indices (sequential from query order)
       - Add edges with parsed EdgeType (Fallthrough, TrueBranch, etc.)
       - Return constructed Cfg

    3. Add serde_json dependency to Cargo.toml if not already present:
       - Check existing dependencies, add serde_json if needed

    Use OptionalExtension trait for optional query results (pattern from Phase 1).
    Return Result<T> with anyhow error context including helpful messages.
  </action>
  <verify>cargo test passes, manual test loads a stored CFG</verify>
  <done>Function resolution and CFG loading work on indexed functions</done>
</task>

<task type="auto">
  <name>Task 2: Export database loading functions for CLI use</name>
  <files>src/storage/mod.rs, src/cfg/mod.rs</files>
  <action>
    1. In src/storage/mod.rs:
       - Export the new functions by adding to pub use section or making them pub
       - Add documentation comments explaining usage

    2. In src/cfg/mod.rs:
       - Add re-export for convenience: pub use crate::storage::{load_cfg_from_db, resolve_function_name}
       - This allows CLI code to use cfg::load_cfg_from_db() for consistency

    3. Add unit tests in storage module:
       - test_resolve_function_by_id: resolves numeric function_id
       - test_resolve_function_by_name: resolves function name string
       - test_resolve_function_not_found: returns error for missing function
       - test_load_cfg_simple: loads a simple 2-block CFG from database
       - test_load_cfg_with_edges: loads CFG with multiple edge types

    Tests should use in-memory database following established pattern:
    - Create Magellan schema
    - Create Mirage schema
    - Insert test function entity
    - Store test CFG using store_cfg()
    - Load and verify structure matches
  </action>
  <verify>cargo test storage::tests passes, all new tests pass</verify>
  <done>Database loading utilities exported and tested</done>
</task>

</tasks>

<verification>
- cargo test --lib passes with new tests
- resolve_function_name() works with both numeric IDs and name strings
- load_cfg_from_db() reconstructs CFG with correct blocks and edges
- Re-exports allow cfg::load_cfg_from_db() usage
</verification>

<success_criteria>
- Shared utility functions for function resolution and CFG loading
- Tests cover success and error cases
- Functions exported for use across CLI commands
</success_criteria>

<output>
After completion, create `.planning/phases/09-mir-integration-database-loading/09-02-SUMMARY.md`
</output>
