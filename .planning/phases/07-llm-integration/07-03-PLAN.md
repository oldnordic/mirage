---
phase: 07-llm-integration
plan: 03
type: execute
wave: 2
depends_on: [07-01]
files_modified: [src/cli/mod.rs, src/output/mod.rs]
autonomous: true

must_haves:
  truths:
    - "Error responses include remediation suggestions"
    - "LLM receives actionable guidance when commands fail"
  artifacts:
    - path: "src/output/mod.rs"
      provides: "Error code constants and remediation helpers"
      min_lines: 40
      contains: ["E001", "E002", "E003", "ErrorCode"]
    - path: "src/cli/mod.rs"
      provides: "Consistent error handling with remediation"
      contains: ["JsonError::new.*with_remediation"]
  key_links:
    - from: "CLI error handlers"
      to: "JsonError with remediation"
      via: "JsonError::new(...).with_remediation(...)"
      pattern: "JsonError::new.*with_remediation"
---

<objective>
Error remediation suggestions for LLM guidance

Purpose: Provide actionable remediation suggestions when CLI commands fail. The `JsonError` struct already has a `remediation` field, but it's not populated consistently. LLMs need specific guidance on how to recover from errors.

Output: Centralized error codes with remediation patterns, all CLI errors include helpful suggestions.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-llm-integration/07-RESEARCH.md
@src/cli/mod.rs
@src/output/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Add error code constants to output module</name>
  <files>src/output/mod.rs</files>
  <action>
    Add error code constants after the existing exit codes (around line 68):

    ```rust
    /// Error codes for JSON error responses
    pub const E_DATABASE_NOT_FOUND: &str = "E001";
    pub const E_FUNCTION_NOT_FOUND: &str = "E002";
    pub const E_BLOCK_NOT_FOUND: &str = "E003";
    pub const E_PATH_NOT_FOUND: &str = "E004";
    pub const E_PATH_EXPLOSION: &str = "E005";
    pub const E_INVALID_INPUT: &str = "E006";
    pub const E_CFG_ERROR: &str = "E007";

    /// Common remediation messages
    pub const R_HINT_INDEX: &str = "Run 'mirage index' to create the database";
    pub const R_HINT_LIST_FUNCTIONS: &str = "Run 'mirage cfg --list-functions' to see available functions";
    pub const R_HINT_MAX_LENGTH: &str = "Use --max-length N to bound path exploration";
    pub const R_HINT_VERIFY_PATH: &str = "Run 'mirage verify --list' to see valid paths";
    ```

    Also add a helper function for common error patterns:
    ```rust
    impl JsonError {
        /// Database not found error with remediation
        pub fn database_not_found(path: &str) -> Self {
            Self::new(
                "DatabaseNotFound",
                &format!("Database not found: {}", path),
                E_DATABASE_NOT_FOUND
            ).with_remediation(R_HINT_INDEX)
        }

        /// Function not found error with remediation
        pub fn function_not_found(name: &str) -> Self {
            Self::new(
                "FunctionNotFound",
                &format!("Function '{}' not found in database", name),
                E_FUNCTION_NOT_FOUND
            ).with_remediation(R_HINT_LIST_FUNCTIONS)
        }

        /// Block not found error
        pub fn block_not_found(id: usize) -> Self {
            Self::new(
                "BlockNotFound",
                &format!("Block {} not found in CFG", id),
                E_BLOCK_NOT_FOUND
            )
        }

        /// Path not found error
        pub fn path_not_found(id: &str) -> Self {
            Self::new(
                "PathNotFound",
                &format!("Path '{}' not found or no longer valid", id),
                E_PATH_NOT_FOUND
            ).with_remediation("Run 'mirage verify --path-id ID' to check path validity")
        }
    }
    ```

    Add this after the existing `impl JsonError` block (after line 149).
  </action>
  <verify>
    grep -n "E_DATABASE_NOT_FOUND\|database_not_found\|function_not_found" src/output/mod.rs
  </verify>
  <done>Error code constants and JsonError helper methods defined</done>
</task>

<task type="auto">
  <name>Update CLI commands to use JsonError helpers</name>
  <files>src/cli/mod.rs</files>
  <action>
    Update error handling in CLI commands to use the new helper methods.

    1. In `status()` function (line ~327):
       Replace:
       ```rust
       output::error(&format!("Failed to open database: {}", e));
       output::info("Hint: Run 'mirage index' to create the database");
       ```
       With JSON-aware error (when output format is JSON):
       ```rust
       if matches!(cli.output, OutputFormat::Json | OutputFormat::Pretty) {
           let error = output::JsonError::database_not_found(&db_path);
           let wrapper = output::JsonResponse::new(error);
           println!("{}", wrapper.to_json());
           std::process::exit(output::EXIT_DATABASE);
       } else {
           output::error(&format!("Failed to open database: {}", e));
           output::info("Hint: Run 'mirage index' to create the database");
           std::process::exit(output::EXIT_DATABASE);
       }
       ```

    2. In `paths()` function (line ~375):
       Apply the same pattern for database errors.

    3. In `cfg()` function (line ~471):
       Apply the same pattern for database errors.

    4. In `dominators()` function (line ~573):
       Apply the same pattern for database errors AND block-not-found errors (line ~606):
       ```rust
       if matches!(cli.output, OutputFormat::Json | OutputFormat::Pretty) {
           let error = output::JsonError::block_not_found(block_id);
           let wrapper = output::JsonResponse::new(error);
           println!("{}", wrapper.to_json());
           std::process::exit(1);
       } else {
           output::error(&format!("Block {} not found in CFG", block_id));
           std::process::exit(1);
       }
       ```

    5. In `unreachable()` function (line ~666):
       Apply the same pattern for database errors.

    6. In `verify()` function (line ~767):
       Apply the same pattern for database errors AND path-not-found errors.
  </action>
  <verify>
    grep -n "database_not_found\|block_not_found\|path_not_found" src/cli/mod.rs
  </verify>
  <done>CLI commands use JsonError helpers with remediation in JSON/pretty mode</done>
</task>

<task type="auto">
  <name>Verify remediation in JSON output</name>
  <files>src/cli/mod.rs, src/output/mod.rs</files>
  <action>
    Test that remediation appears in JSON output:

    1. Test database not found:
       ```bash
       cargo build --quiet
       ./target/debug/mirage status --db /nonexistent/db.json --output json | jq '.data.remediation'
       ```
       Expected: `"Run 'mirage index' to create the database"`

    2. Test block not found (use dominators command):
       ```bash
       ./target/debug/mirage dominators --must-pass-through 999 --output json | jq '.data.remediation'
       ```
       Expected: null or specific message (block not found)

    Run existing tests:
    ```bash
    cargo test --quiet 2>&1 | grep -E "(test result:|FAILED)"
    ```
  </action>
  <verify>
    ./target/debug/mirage status --db /tmp/does-not-exist.json --output json 2>&1 | jq -e '.data.remediation'
  </verify>
  <done>JSON errors include remediation field with actionable suggestions</done>
</task>

</tasks>

<verification>
1. Compile succeeds: `cargo check --quiet`
2. All existing tests pass: `cargo test --quiet`
3. Database errors show remediation in JSON output
4. Function/block not found errors show appropriate hints
5. Human mode still shows readable errors with hints
6. Error codes are consistent (E001, E002, etc.)
</verification>

<success_criteria>
1. All CLI errors in JSON/pretty mode include remediation field
2. Error codes use consistent E### format
3. Remediation messages are actionable (suggest specific commands)
4. Human mode still works with readable output
5. LLMs can parse error categories and suggest fixes to users
</success_criteria>

<output>
After completion, create `.planning/phases/07-llm-integration/07-03-SUMMARY.md`
</output>
