---
phase: 06-cli-interface
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/cli/mod.rs]
autonomous: true

must_haves:
  truths:
    - "mirage paths --function SYMBOL shows all paths for function"
    - "mirage paths --show-errors shows only error paths"
    - "mirage paths --max-length N bounds path exploration"
  artifacts:
    - path: "src/cli/mod.rs"
      provides: "Implemented paths() command handler"
      min_lines: 50
  key_links:
    - from: "src/cli/mod.rs::paths()"
      to: "src/cfg/paths.rs::enumerate_paths_cached"
      via: "direct function call"
      pattern: "enumerate_paths_cached|get_or_enumerate_paths"
---

<objective>
Implement the `mirage paths` command to display enumerated execution paths through a function. This connects the CLI stub to the path enumeration backend from Phase 5, supporting filtering by error paths and bounding by maximum length.

**Purpose:** Enable users to query execution paths through functions with optional filtering for error paths and length limits.

**Output:** Working `mirage paths` command with human/JSON/pretty output formats.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-cli-interface/06-RESEARCH.md
@src/cli/mod.rs
@src/cfg/paths.rs
@src/storage/paths.rs
</context>

<tasks>

<task type="auto">
  <name>Implement paths() command handler with database integration</name>
  <files>src/cli/mod.rs</files>
  <action>
  In `src/cli/mod.rs`, replace the stub `paths()` function with a full implementation:

  1. Update signature from `paths(_args: PathsArgs)` to `paths(args: PathsArgs, cli: &Cli)` to match the pattern for commands needing global context

  2. Add database connection using `MirageDb::open()` with the resolved path from `resolve_db_path(cli.db.clone())`

  3. Handle database open errors with helpful hint message (follow existing status command pattern)

  4. For now, use test CFG since MIR extraction (Phase 2's index command) isn't complete:
     - Call `create_test_cfg()` to get a CFG
     - Call `enumerate_paths_cached()` or `get_or_enumerate_paths()` from `src/cfg/paths.rs`
     - Apply PathLimits based on args.max_length if provided

  5. Filter paths if args.show_errors is true:
     - Only include paths where path.kind == PathKind::Error

  6. Format output based on cli.output:
     - Human: Print each path with path_id, kind, length, blocks
     - Json/Pretty: Wrap in JsonResponse with PathSummary structs

  7. Handle the case where function lookup fails (graceful error)

  **Key imports to add:**
  - `use crate::cfg::{Path, PathKind, PathLimits, enumerate_paths_cached};`
  - `use crate::storage::MirageDb;`
  - `use crate::output;`

  **Response struct for JSON output:**
  ```rust
  #[derive(serde::Serialize)]
  struct PathsResponse {
      function: String,
      total_paths: usize,
      error_paths: usize,
      paths: Vec<PathSummary>,
  }

  #[derive(serde::Serialize)]
  struct PathSummary {
      path_id: String,
      kind: String,
      length: usize,
      blocks: Vec<usize>,
  }
  ```
  </action>
  <verify>
  Run `cargo build` to verify compilation. Run `cargo test paths` to verify any tests pass.
  </verify>
  <done>
  The paths() command successfully:
  - Connects to the Mirage database
  - Enumerates paths through a function (using test CFG for now)
  - Filters to show only error paths when --show-errors flag is set
  - Applies max-length limit when --max-length N is provided
  - Outputs in human/json/pretty formats based on --output flag
  </done>
</task>

<task type="auto">
  <name>Add tests for paths command output formatting</name>
  <files>src/cli/mod.rs</files>
  <action>
  In the `#[cfg(test)] mod tests` section of `src/cli/mod.rs`, add:

  1. Test for human output format parsing (verify args.function is extracted)
  2. Test for show_errors flag behavior
  3. Test for max_length limit application
  4. Integration test that creates a test CFG and verifies paths() returns expected output

  Tests should use the existing `create_test_cfg()` helper function.
  </action>
  <verify>
  Run `cargo test` to verify all tests pass.
  </verify>
  <done>
  Tests cover the paths() command behavior including filtering and output formatting.
  </done>
</task>

</tasks>

<verification>
Overall phase checks:
- [ ] `cargo build` succeeds with no warnings
- [ ] `cargo test` passes all tests
- [ ] paths() command connects to database and returns paths
- [ ] --show-errors flag filters to error paths only
- [ ] --max-length flag is applied to path enumeration
- [ ] All three output formats (human/json/pretty) work correctly
</verification>

<success_criteria>
1. `mirage paths --function test_func` displays enumerated paths
2. `mirage paths --function test_func --show-errors` shows only PathKind::Error paths
3. `mirage paths --function test_func --max-length 5` limits paths to 5 blocks max
4. `mirage paths --function test_func --output json` outputs valid JSON
5. `mirage paths --function test_func --output pretty` outputs formatted JSON
</success_criteria>

<output>
After completion, create `.planning/phases/06-cli-interface/06-01-SUMMARY.md`
</output>
