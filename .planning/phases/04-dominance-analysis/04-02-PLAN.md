---
phase: 04-dominance-analysis
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/cfg/mod.rs
  - src/cfg/post_dominators.rs
autonomous: true

must_haves:
  truths:
    - "Post-dominator tree can be computed for any CFG with single exit point"
    - "Post-dominance is dual to dominance (computed on reversed graph)"
    - "post_dominates(a, b) checks if all paths from b to exit contain a"
    - "Zero-copy Reversed adaptor is used (no graph cloning)"
  artifacts:
    - path: "src/cfg/post_dominators.rs"
      provides: "PostDominatorTree wrapper using graph reversal"
      exports: ["PostDominatorTree", "compute_post_dominator_tree", "post_dominates"]
    - path: "src/cfg/mod.rs"
      provides: "pub mod post_dominators"
      exports: ["pub use post_dominators::*"]
  key_links:
    - from: "src/cfg/post_dominators.rs"
      to: "petgraph::visit::Reversed"
      via: "use petgraph::visit::Reversed"
      pattern: "petgraph::visit::Reversed"
    - from: "src/cfg/post_dominators.rs"
      to: "src/cfg/analysis.rs"
      via: "find_exits function"
      pattern: "crate::cfg::analysis::find_exits"
    - from: "src/cfg/post_dominators.rs"
      to: "src/cfg/dominators.rs"
      via: "reuses DominatorTree internals"
      pattern: "DominatorTree"
---

<objective>
Implement post-dominator tree construction using graph reversal with petgraph's Reversed adaptor, transforming post-dominance into dominance on the reversed graph.

Purpose: Post-dominance determines what code MUST execute on any path from a node to exit. Critical for control dependence analysis and "must-execute-through" proofs. Reversal adaptor enables zero-computation transformation.
Output: post_dominators.rs module with PostDominatorTree struct providing immediate_post_dominator(), post_dominates(), and compute_post_dominator_tree().
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/04-dominance-analysis/04-RESEARCH.md
@.planning/STATE.md
@src/cfg/mod.rs
@src/cfg/analysis.rs
@src/cfg/dominators.rs

# Research highlights (from 04-RESEARCH.md)
- Post-dominance is dual to dominance: A post-dominates B iff all paths B -> exit contain A
- Computed by running dominance algorithm on reversed CFG using Reversed<G> adaptor
- Reversed<G> is zero-copy view (not a clone) - critical for performance
- Root of post-dominator tree is exit node(s)

# Key warnings from research
- PITFALL 2: Functions may have multiple exits (Return, Abort, Unreachable). Use primary exit for now.
- Don't use Reversed without understanding zero-copy - it's a view adaptor, not a clone
- Post-dominance from single exit undefined if multiple exits exist

# Existing patterns
- 04-01 established DominatorTree pattern - reuse for PostDominatorTree internals
- analysis.rs provides find_exits() for exit detection
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create post_dominators module with PostDominatorTree struct</name>
  <files>src/cfg/post_dominators.rs, src/cfg/mod.rs</files>
  <action>
    Create src/cfg/post_dominators.rs with post-dominator tree wrapper:

    ```rust
    //! Post-dominator tree construction and queries
    //!
    //! A node d post-dominates node n if every path from n to an exit node
    //! must go through d. Post-dominance is the dual of dominance, computed
    //! by running the dominance algorithm on a reversed CFG.

    use crate::cfg::{Cfg, BlockId};
    use crate::cfg::analysis::find_exits;
    use crate::cfg::dominators::DominatorTree;
    use petgraph::algo::dominators::simple_fast;
    use petgraph::graph::NodeIndex;
    use petgraph::visit::Reversed;
    use std::collections::HashMap;

    /// Post-dominator tree for a CFG
    ///
    /// Computed by running the dominance algorithm on a reversed CFG.
    /// The root is the exit node.
    ///
    /// # Example
    /// ```rust
    /// let post_dom_tree = PostDominatorTree::new(&cfg)?;
    /// if let Some(ipdom) = post_dom_tree.immediate_post_dominator(node) {
    ///     println!("Node {:?} is post-dominated by {:?}", node, ipdom);
    /// }
    /// ```
    #[derive(Debug, Clone)]
    pub struct PostDominatorTree {
        /// Dominator tree on reversed graph (isomorphic to post-dominator tree)
        inner: DominatorTree,
        /// Root node (exit block)
        exit: NodeIndex,
    }

    impl PostDominatorTree {
        /// Compute post-dominator tree using graph reversal
        ///
        /// Returns None if CFG has no exit nodes.
        ///
        /// Algorithm:
        /// 1. Find primary exit node (first Return terminator)
        /// 2. Reverse graph edges using Reversed<G> adaptor
        /// 3. Compute dominators with exit as root
        /// 4. Result is post-dominators on original graph
        ///
        /// Time: O(|V|Â²) worst case, faster in practice
        /// Space: O(|V| + |E|)
        ///
        /// # Limitations
        /// - Uses primary exit only. Functions with multiple exits
        ///   (Return + Abort + Unreachable) may have incomplete post-dominators.
        /// - Returns None if no exit nodes found.
        pub fn new(cfg: &Cfg) -> Option<Self> {
            // Find exit node(s) - use primary exit (first Return node)
            let exits = find_exits(cfg);
            let exit = exits.first().copied()?;

            // Reverse the graph (zero-copy view)
            let reversed = Reversed(cfg);

            // Compute dominators on reversed graph
            let dominators = simple_fast(reversed, exit);

            // Build DominatorTree from reversed dominators
            let mut immediate_dominator = HashMap::new();
            let mut children: HashMap<NodeIndex, Vec<NodeIndex>> = HashMap::new();

            for node in cfg.node_indices() {
                let idom = dominators.immediate_dominator(node);
                immediate_dominator.insert(node, idom);

                if let Some(parent) = idom {
                    children.entry(parent).or_default().push(node);
                }
            }

            // Manually construct DominatorTree (we can't use DominatorTree::new
            // because it would use the wrong graph direction)
            let inner = DominatorTree::from_parts(exit, immediate_dominator, children);

            Some(Self { inner, exit })
        }

        /// Get the root node of the post-dominator tree
        ///
        /// The root is the exit node of the CFG.
        pub fn root(&self) -> NodeIndex {
            self.exit
        }

        /// Get immediate post-dominator of a node
        ///
        /// Returns None for the exit node (which has no post-dominator).
        ///
        /// # Example
        /// ```rust
        /// if let Some(ipdom) = post_dom_tree.immediate_post_dominator(node) {
        ///     println!("Immediately post-dominated by {:?}", ipdom);
        /// } else {
        ///     println!("This is the exit node");
        /// }
        /// ```
        pub fn immediate_post_dominator(&self, node: NodeIndex) -> Option<NodeIndex> {
            self.inner.immediate_dominator(node)
        }

        /// Check if `a` post-dominates `b`
        ///
        /// A post-dominates B if every path from B to exit contains A.
        /// By definition, every node post-dominates itself.
        ///
        /// # Example
        /// ```rust
        /// if post_dom_tree.post_dominates(exit, node) {
        ///     println!("exit post-dominates node (always true for nodes that can reach exit)");
        /// }
        /// ```
        pub fn post_dominates(&self, a: NodeIndex, b: NodeIndex) -> bool {
            self.inner.dominates(a, b)
        }

        /// Get all nodes immediately post-dominated by `node`
        ///
        /// Returns the children of `node` in the post-dominator tree.
        pub fn children(&self, node: NodeIndex) -> &[NodeIndex] {
            self.inner.children(node)
        }

        /// Check if `a` strictly post-dominates `b`
        ///
        /// A strictly post-dominates B if A post-dominates B and A != B.
        pub fn strictly_post_dominates(&self, a: NodeIndex, b: NodeIndex) -> bool {
            self.inner.strictly_dominates(a, b)
        }

        /// Get all post-dominators of a node (including itself)
        ///
        /// Returns iterator from node up to exit.
        pub fn post_dominators(&self, node: NodeIndex) -> PostDominators<'_> {
            PostDominators {
                tree: self,
                current: Some(node),
            }
        }

        /// Get the nearest common post-dominator of two nodes
        ///
        /// Returns the node that post-dominates both `a` and `b` and is
        /// post-dominated by all other common post-dominators.
        pub fn common_post_dominator(&self, a: NodeIndex, b: NodeIndex) -> Option<NodeIndex> {
            // Collect a's post-dominators
            let a_pdoms: std::collections::HashSet<NodeIndex> =
                self.post_dominators(a).collect();

            // Find first (nearest) post-dominator of b that's also in a's post-dominators
            for pdom in self.post_dominators(b) {
                if a_pdoms.contains(&pdom) {
                    return Some(pdom);
                }
            }

            None
        }

        /// Get depth of node in post-dominator tree
        ///
        /// Exit has depth 0, its children have depth 1, etc.
        pub fn depth(&self, node: NodeIndex) -> usize {
            self.inner.depth(node)
        }

        /// Get the underlying DominatorTree (for advanced use)
        ///
        /// This exposes the internal dominator tree structure on the reversed graph.
        pub fn as_dominator_tree(&self) -> &DominatorTree {
            &self.inner
        }
    }

    /// Iterator over a node's post-dominators (from node up to exit)
    pub struct PostDominators<'a> {
        tree: &'a PostDominatorTree,
        current: Option<NodeIndex>,
    }

    impl<'a> Iterator for PostDominators<'a> {
        type Item = NodeIndex;

        fn next(&mut self) -> Option<Self::Item> {
            let node = self.current?;
            self.current = self.tree.immediate_post_dominator(node);
            Some(node)
        }
    }

    /// Convenience function to compute post-dominator tree
    ///
    /// This is a shorthand for PostDominatorTree::new().
    ///
    /// # Example
    /// ```rust
    /// let post_dom_tree = compute_post_dominator_tree(&cfg)?;
    /// ```
    pub fn compute_post_dominator_tree(cfg: &Cfg) -> Option<PostDominatorTree> {
        PostDominatorTree::new(cfg)
    }

    /// Get immediate post-dominator as BlockId
    ///
    /// Convenience function that converts NodeIndex to BlockId.
    pub fn immediate_post_dominator_id(tree: &PostDominatorTree, block_id: BlockId, cfg: &Cfg) -> Option<BlockId> {
        let node = node_from_id(cfg, block_id)?;
        let ipdom_node = tree.immediate_post_dominator(node)?;
        Some(cfg[ipdom_node].id)
    }

    /// Helper: find NodeIndex from BlockId
    fn node_from_id(cfg: &Cfg, block_id: BlockId) -> Option<NodeIndex> {
        cfg.node_indices()
            .find(|&n| cfg[n].id == block_id)
    }

    // Extend DominatorTree with a constructor from parts
    // This is a workaround to build the internal tree structure
    trait DominatorTreeExt {
        fn from_parts(
            root: NodeIndex,
            immediate_dominator: HashMap<NodeIndex, Option<NodeIndex>>,
            children: HashMap<NodeIndex, Vec<NodeIndex>>,
        ) -> Self;
    }

    impl DominatorTreeExt for DominatorTree {
        fn from_parts(
            root: NodeIndex,
            immediate_dominator: HashMap<NodeIndex, Option<NodeIndex>>,
            children: HashMap<NodeIndex, Vec<NodeIndex>>,
        ) -> Self {
            // Use private constructor pattern via transmutation
            // Since DominatorTree's fields are private, we need to create it via new()
            // and then swap the internals. For now, we'll reconstruct using the public API.

            // Actually, we need to extend DominatorTree in 04-01 to support this.
            // For this plan, we'll modify the DominatorTree to add a with_parts() method.

            // WORKAROUND: Create a new DominatorTree and use the internal structure
            // Since we can't access private fields, we'll add a method to DominatorTree.

            Self {
                root,
                immediate_dominator,
                children,
            }
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::cfg::{BasicBlock, BlockKind, Terminator, EdgeType};
        use petgraph::graph::DiGraph;

        /// Create a simple diamond CFG:
        ///     0 (entry)
        ///    / \
        ///   1   2
        ///    \ /
        ///     3 (exit)
        fn create_diamond_cfg() -> Cfg {
            let mut g = DiGraph::new();

            let b0 = g.add_node(BasicBlock {
                id: 0,
                kind: BlockKind::Entry,
                statements: vec![],
                terminator: Terminator::SwitchInt { targets: vec![1], otherwise: 2 },
                source_location: None,
            });

            let b1 = g.add_node(BasicBlock {
                id: 1,
                kind: BlockKind::Normal,
                statements: vec!["branch 1".to_string()],
                terminator: Terminator::Goto { target: 3 },
                source_location: None,
            });

            let b2 = g.add_node(BasicBlock {
                id: 2,
                kind: BlockKind::Normal,
                statements: vec!["branch 2".to_string()],
                terminator: Terminator::Goto { target: 3 },
                source_location: None,
            });

            let b3 = g.add_node(BasicBlock {
                id: 3,
                kind: BlockKind::Exit,
                statements: vec![],
                terminator: Terminator::Return,
                source_location: None,
            });

            g.add_edge(b0, b1, EdgeType::TrueBranch);
            g.add_edge(b0, b2, EdgeType::FalseBranch);
            g.add_edge(b1, b3, EdgeType::Fallthrough);
            g.add_edge(b2, b3, EdgeType::Fallthrough);

            g
        }

        #[test]
        fn test_post_dominator_tree_construction() {
            let cfg = create_diamond_cfg();
            let post_dom_tree = PostDominatorTree::new(&cfg).expect("CFG has exit");

            // Exit (3) is root
            assert_eq!(post_dom_tree.root(), NodeIndex::new(3));

            // Exit has no immediate post-dominator
            assert_eq!(post_dom_tree.immediate_post_dominator(NodeIndex::new(3)), None);

            // Node 1 is immediately post-dominated by exit (3)
            assert_eq!(post_dom_tree.immediate_post_dominator(NodeIndex::new(1)), Some(NodeIndex::new(3)));

            // Node 2 is immediately post-dominated by exit (3)
            assert_eq!(post_dom_tree.immediate_post_dominator(NodeIndex::new(2)), Some(NodeIndex::new(3)));

            // Node 0 is immediately post-dominated by exit (3) in diamond CFG
            assert_eq!(post_dom_tree.immediate_post_dominator(NodeIndex::new(0)), Some(NodeIndex::new(3)));
        }

        #[test]
        fn test_post_dominates() {
            let cfg = create_diamond_cfg();
            let post_dom_tree = PostDominatorTree::new(&cfg).expect("CFG has exit");

            let exit = NodeIndex::new(3);
            let entry = NodeIndex::new(0);

            // Exit post-dominates all nodes that can reach it
            assert!(post_dom_tree.post_dominates(exit, exit));
            assert!(post_dom_tree.post_dominates(exit, entry));

            // Entry does not post-dominate exit
            assert!(!post_dom_tree.post_dominates(entry, exit));

            // Every node post-dominates itself
            assert!(post_dom_tree.post_dominates(entry, entry));
            assert!(post_dom_tree.post_dominates(exit, exit));
        }

        #[test]
        fn test_children() {
            let cfg = create_diamond_cfg();
            let post_dom_tree = PostDominatorTree::new(&cfg).expect("CFG has exit");

            let exit = NodeIndex::new(3);
            let children = post_dom_tree.children(exit);

            // Exit has children 0, 1, and 2 (in diamond CFG)
            assert_eq!(children.len(), 3);
            assert!(children.contains(&NodeIndex::new(0)));
            assert!(children.contains(&NodeIndex::new(1)));
            assert!(children.contains(&NodeIndex::new(2)));
        }

        #[test]
        fn test_strictly_post_dominates() {
            let cfg = create_diamond_cfg();
            let post_dom_tree = PostDominatorTree::new(&cfg).expect("CFG has exit");

            let exit = NodeIndex::new(3);
            let node1 = NodeIndex::new(1);

            // Exit strictly post-dominates node1
            assert!(post_dom_tree.strictly_post_dominates(exit, node1));

            // Exit does NOT strictly post-dominate itself
            assert!(!post_dom_tree.strictly_post_dominates(exit, exit));
        }

        #[test]
        fn test_post_dominators_iterator() {
            let cfg = create_diamond_cfg();
            let post_dom_tree = PostDominatorTree::new(&cfg).expect("CFG has exit");

            let entry = NodeIndex::new(0);
            let pdoms: Vec<_> = post_dom_tree.post_dominators(entry).collect();

            // Entry's post-dominators: 0 itself, and 3 (exit)
            assert_eq!(pdoms.len(), 2);
            assert_eq!(pdoms[0], entry);
            assert_eq!(pdoms[1], NodeIndex::new(3));
        }

        #[test]
        fn test_common_post_dominator() {
            let cfg = create_diamond_cfg();
            let post_dom_tree = PostDominatorTree::new(&cfg).expect("CFG has exit");

            let node1 = NodeIndex::new(1);
            let node2 = NodeIndex::new(2);
            let exit = NodeIndex::new(3);

            // Common post-dominator of 1 and 2 is exit (3)
            assert_eq!(post_dom_tree.common_post_dominator(node1, node2), Some(exit));

            // Common post-dominator of node with itself is the node
            assert_eq!(post_dom_tree.common_post_dominator(node1, node1), Some(node1));
        }

        #[test]
        fn test_depth() {
            let cfg = create_diamond_cfg();
            let post_dom_tree = PostDominatorTree::new(&cfg).expect("CFG has exit");

            // Exit has depth 0
            assert_eq!(post_dom_tree.depth(NodeIndex::new(3)), 0);

            // Children of exit have depth 1
            assert_eq!(post_dom_tree.depth(NodeIndex::new(0)), 1);
            assert_eq!(post_dom_tree.depth(NodeIndex::new(1)), 1);
            assert_eq!(post_dom_tree.depth(NodeIndex::new(2)), 1);
        }

        #[test]
        fn test_empty_cfg() {
            let cfg: Cfg = DiGraph::new();
            assert!(PostDominatorTree::new(&cfg).is_none());
        }

        #[test]
        fn test_linear_cfg() {
            // Linear: 0 -> 1 -> 2 -> 3
            let mut g = DiGraph::new();

            let b0 = g.add_node(BasicBlock {
                id: 0,
                kind: BlockKind::Entry,
                statements: vec![],
                terminator: Terminator::Goto { target: 1 },
                source_location: None,
            });

            let b1 = g.add_node(BasicBlock {
                id: 1,
                kind: BlockKind::Normal,
                statements: vec![],
                terminator: Terminator::Goto { target: 2 },
                source_location: None,
            });

            let b2 = g.add_node(BasicBlock {
                id: 2,
                kind: BlockKind::Normal,
                statements: vec![],
                terminator: Terminator::Goto { target: 3 },
                source_location: None,
            });

            let b3 = g.add_node(BasicBlock {
                id: 3,
                kind: BlockKind::Exit,
                statements: vec![],
                terminator: Terminator::Return,
                source_location: None,
            });

            g.add_edge(b0, b1, EdgeType::Fallthrough);
            g.add_edge(b1, b2, EdgeType::Fallthrough);
            g.add_edge(b2, b3, EdgeType::Fallthrough);

            let post_dom_tree = PostDominatorTree::new(&g).expect("CFG has exit");

            // In linear CFG, each node i is post-dominated by i+1, i+2, ..., 3
            assert_eq!(post_dom_tree.immediate_post_dominator(b3), None);
            assert_eq!(post_dom_tree.immediate_post_dominator(b2), Some(b3));
            assert_eq!(post_dom_tree.immediate_post_dominator(b1), Some(b2));
            assert_eq!(post_dom_tree.immediate_post_dominator(b0), Some(b1));
        }

        #[test]
        fn test_reversed_is_zero_copy() {
            // This test verifies that Reversed is a view, not a clone
            let cfg = create_diamond_cfg();

            // Reversed should be a view - same node count
            let reversed = Reversed(&cfg);
            assert_eq!(reversed.node_count(), cfg.node_count());
            assert_eq!(reversed.edge_count(), cfg.edge_count());
        }
    }
    ```

    2. Update src/cfg/mod.rs:
       Add to module declarations:
       ```rust
       pub mod post_dominators;
       pub use post_dominators::{PostDominatorTree, compute_post_dominator_tree};
       ```

    3. Update src/cfg/dominators.rs to support construction from parts:
       Add the following method to DominatorTree (before the impl block ends):
       ```rust
       /// Create DominatorTree from pre-computed parts
       ///
       /// This is used internally by PostDominatorTree to construct
       /// a dominator tree on a reversed graph.
       pub(crate) fn from_parts(
           root: NodeIndex,
           immediate_dominator: HashMap<NodeIndex, Option<NodeIndex>>,
           children: HashMap<NodeIndex, Vec<NodeIndex>>,
       ) -> Self {
       Self {
           root,
           immediate_dominator,
           children,
       }
   }
   ```

    4. Update post_dominators.rs to use DominatorTree::from_parts:
       Remove the DominatorTreeExt trait and replace with:
       ```rust
       let inner = DominatorTree::from_parts(exit, immediate_dominator, children);
   ```
  </action>
  <verify>cargo check passes without errors</verify>
  <done>post_dominators module created with PostDominatorTree struct and comprehensive tests</done>
</task>

</tasks>

<verification>
1. Type checking: cargo check passes with no errors
2. Module visibility: PostDominatorTree and compute_post_dominator_tree exported from crate root
3. Test coverage: Diamond CFG, linear CFG, empty CFG, post-dominators iterator, common post-dominator all tested
4. Graph reversal: Uses Reversed<G> adaptor (zero-copy view)
5. Integration: DominatorTree::from_parts supports post-dominator construction
</verification>

<success_criteria>
- [ ] src/cfg/post_dominators.rs exists with PostDominatorTree struct
- [ ] PostDominatorTree::new() computes post-dominator tree using Reversed adaptor
- [ ] immediate_post_dominator() returns parent in post-dominator tree (None for exit)
- [ ] post_dominates(a, b) correctly checks post-dominance relationship
- [ ] children() returns all immediately post-dominated nodes
- [ ] PostDominators iterator walks up post-dominator chain
- [ ] common_post_dominator() finds nearest common post-dominator
- [ ] Reversed adaptor is used (zero-copy, not graph cloning)
- [ ] DominatorTree::from_parts() added for internal construction
- [ ] All functions exported from crate root
- [ ] cargo test --lib post_dominators passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-dominance-analysis/04-02-SUMMARY.md`
</output>
