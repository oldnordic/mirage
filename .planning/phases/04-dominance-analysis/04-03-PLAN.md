---
phase: 04-dominance-analysis
plan: 03
type: execute
wave: 3
depends_on: ["04-01"]
files_modified:
  - src/cfg/mod.rs
  - src/cfg/dominance_frontiers.rs
autonomous: true

must_haves:
  truths:
    - "Dominance frontier identifies join points in control flow"
    - "DF[n] contains nodes where n's dominance region ends"
    - "frontier(n) returns HashSet of nodes in n's dominance frontier"
    - "Cytron et al. algorithm correctly computes frontiers"
  artifacts:
    - path: "src/cfg/dominance_frontiers.rs"
      provides: "DominanceFrontiers struct using Cytron et al. algorithm"
      exports: ["DominanceFrontiers", "compute_dominance_frontiers", "frontier"]
    - path: "src/cfg/mod.rs"
      provides: "pub mod dominance_frontiers"
      exports: ["pub use dominance_frontiers::*"]
  key_links:
    - from: "src/cfg/dominance_frontiers.rs"
      to: "src/cfg/dominators.rs"
      via: "DominatorTree for dominance queries"
      pattern: "DominatorTree"
    - from: "src/cfg/dominance_frontiers.rs"
      to: "src/cfg/mod.rs"
      via: "Cfg type for iteration"
      pattern: "Cfg"
---

<objective>
Implement dominance frontier computation using Cytron et al.'s iterative algorithm, identifying join points in control flow where dominance boundaries meet.

Purpose: Dominance frontiers are critical for SSA phi-node placement and control dependence analysis. They identify where values from multiple control paths must merge. This implementation uses the standard iterative algorithm with O(|V|²) complexity.
Output: dominance_frontiers.rs module with DominanceFrontiers struct providing frontier(), in_frontier(), and compute_dominance_frontiers().
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/04-dominance-analysis/04-RESEARCH.md
@.planning/STATE.md
@src/cfg/mod.rs
@src/cfg/dominators.rs

# Research highlights (from 04-RESEARCH.md)
- Cytron et al. 1991 algorithm: DF[n] = { v | exists p in pred(v): n dominates p AND n does NOT strictly dominate v }
- Intuition: v is a "join point" where control from n's region meets control from outside
- Process nodes in dominator tree post-order (children before parents)
- Two rules: (1) strict dominance boundary, (2) propagate children's frontiers

# Key warnings from research
- PITFALL 3: Naive O(|V|²) frontier computation can be slow - cache dominance checks
- For CFGs up to ~1000 nodes, straightforward algorithm is fine
- Profile if >100ms for typical functions

# Algorithm (Cytron et al.)
```
For each node n:
  DF[n] = empty set
  For each node v:
    For each predecessor p of v:
      If n dominates p AND n does NOT strictly dominate v:
        Add v to DF[n]
  For each child c of n in dominator tree:
    DF[n] = DF[n] union (DF[c] - {nodes strictly dominated by n})
```

# Existing patterns
- 04-01 established DominatorTree API - use dominates() and children()
- Edge iteration: cfg.neighbors_directed(v, Direction::Incoming)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dominance_frontiers module with DominanceFrontiers struct</name>
  <files>src/cfg/dominance_frontiers.rs, src/cfg/mod.rs</files>
  <action>
    Create src/cfg/dominance_frontiers.rs with dominance frontier computation:

    ```rust
    //! Dominance frontier computation
    //!
    //! The dominance frontier of a node n is the set of nodes where
    //! dominance from n ends. These are join points in the CFG where
    //! control flow from n's dominated region meets control from outside.
    //!
    //! Dominance frontiers are used for:
    //! - SSA phi-node placement (where variables merge from multiple paths)
    //! - Control dependence analysis
    //! - Identifying join points in control flow

    use crate::cfg::Cfg;
    use crate::cfg::dominators::DominatorTree;
    use petgraph::graph::NodeIndex;
    use std::collections::{HashSet, HashMap};

    /// Dominance frontiers for all nodes in a CFG
    ///
    /// The dominance frontier of node n is the set of nodes v such that:
    /// - n dominates a predecessor of v, AND
    /// - n does NOT strictly dominate v
    ///
    /// Intuitively, these are the "join points" where control from n's
    /// region meets control from outside n's region.
    ///
    /// # Example
    /// ```rust
    /// let dom_tree = DominatorTree::new(&cfg)?;
    /// let frontiers = DominanceFrontiers::new(&cfg, dom_tree);
    ///
    /// for node in frontiers.frontier(some_node) {
    ///     println!("{:?} is in {:?}'s dominance frontier", node, some_node);
    /// }
    /// ```
    #[derive(Debug, Clone)]
    pub struct DominanceFrontiers {
        /// Dominance frontier for each node
        frontiers: HashMap<NodeIndex, HashSet<NodeIndex>>,
        /// Dominator tree for dominance queries
        dominator_tree: DominatorTree,
    }

    impl DominanceFrontiers {
        /// Compute dominance frontiers for all nodes using Cytron et al. algorithm
        ///
        /// Algorithm (Cytron et al. 1991):
        /// 1. Process nodes in reverse post-order of dominator tree
        /// 2. For each node n:
        ///    a. Add v where n dominates pred(v) but not v
        ///    b. Union with children's frontiers (excluding strict dominators)
        ///
        /// Complexity: O(|V|²) for worst-case CFG
        ///
        /// # Example
        /// ```rust
        /// let dom_tree = DominatorTree::new(&cfg)?;
        /// let frontiers = DominanceFrontiers::new(&cfg, dom_tree);
        /// ```
        pub fn new(cfg: &Cfg, dominator_tree: DominatorTree) -> Self {
            let mut frontiers: HashMap<NodeIndex, HashSet<NodeIndex>> = HashMap::new();

            // Process nodes in reverse post-order (deep nodes first)
            // We'll use depth in dominator tree as approximation
            let mut nodes: Vec<NodeIndex> = cfg.node_indices().collect();
            nodes.sort_by_key(|&n| std::cmp::Reverse(dominator_tree.depth(n)));

            // Compute frontier for each node
            for &n in &nodes {
                let mut df = HashSet::new();

                // Rule 1: Strict dominance boundary
                // For each node v, check if n dominates a predecessor of v
                // but does NOT strictly dominate v itself
                for &v in &nodes {
                    for p in cfg.neighbors_directed(v, petgraph::Direction::Incoming) {
                        if dominator_tree.dominates(n, p)
                            && !dominator_tree.strictly_dominates(n, v)
                        {
                            df.insert(v);
                        }
                    }
                }

                // Rule 2: Propagate children's frontiers
                // If child c's frontier contains v and n does not strictly dominate v
                // then v is in n's dominance frontier
                for &child in dominator_tree.children(n) {
                    if let Some(child_df) = frontiers.get(&child) {
                        for &v in child_df {
                            if !dominator_tree.strictly_dominates(n, v) {
                                df.insert(v);
                            }
                        }
                    }
                }

                frontiers.insert(n, df);
            }

            Self { frontiers, dominator_tree }
        }

        /// Get dominance frontier for a node
        ///
        /// Returns empty set if node has no dominance frontier
        /// (e.g., node that doesn't dominate any branching code).
        ///
        /// # Example
        /// ```rust
        /// let df = frontiers.frontier(node);
        /// println!("Node {:?} has {} nodes in its dominance frontier", node, df.len());
        /// ```
        pub fn frontier(&self, node: NodeIndex) -> &HashSet<NodeIndex> {
            self.frontiers.get(&node).map_or(&HashSet::new(), |s| s)
        }

        /// Check if `v` is in `n`'s dominance frontier
        ///
        /// Returns true if v is a join point where n's dominance ends.
        ///
        /// # Example
        /// ```rust
        /// if frontiers.in_frontier(n, v) {
        ///     println!("{:?} is where {:?}'s dominance ends", v, n);
        /// }
        /// ```
        pub fn in_frontier(&self, n: NodeIndex, v: NodeIndex) -> bool {
            self.frontier(n).contains(&v)
        }

        /// Get reference to the underlying dominator tree
        ///
        /// Useful for additional dominance queries.
        pub fn dominator_tree(&self) -> &DominatorTree {
            &self.dominator_tree
        }

        /// Get all nodes with non-empty dominance frontiers
        ///
        /// These are the nodes that have join points in their dominated regions.
        pub fn nodes_with_frontiers(&self) -> impl Iterator<Item = NodeIndex> + '_ {
            self.frontiers.iter()
                .filter(|(_, df)| !df.is_empty())
                .map(|(&n, _)| n)
        }

        /// Find the iterated dominance frontier
        ///
        /// The iterated dominance frontier is the closure of the dominance
        /// frontier under the dominance relation. Used for placing phi nodes
        /// in SSA construction.
        ///
        /// Algorithm: Iteratively add frontier nodes until fixed point.
        pub fn iterated_frontier(&self, nodes: &[NodeIndex]) -> HashSet<NodeIndex> {
            let mut result = HashSet::new();
            let mut worklist: Vec<NodeIndex> = nodes.to_vec();

            while let Some(n) = worklist.pop() {
                for &v in self.frontier(n) {
                    if result.insert(v) {
                        worklist.push(v);
                    }
                }
            }

            result
        }

        /// Compute dominance frontier for a set of nodes
        ///
        /// Returns the union of each node's dominance frontier.
        pub fn union_frontier(&self, nodes: &[NodeIndex]) -> HashSet<NodeIndex> {
            nodes.iter()
                .flat_map(|&n| self.frontier(n).iter().copied())
                .collect()
        }
    }

    /// Convenience function to compute dominance frontiers
    ///
    /// This is a shorthand for DominanceFrontiers::new().
    ///
    /// # Example
    /// ```rust
    /// let dom_tree = DominatorTree::new(&cfg)?;
    /// let frontiers = compute_dominance_frontiers(&cfg, dom_tree)?;
    /// ```
    pub fn compute_dominance_frontiers(cfg: &Cfg, dominator_tree: DominatorTree) -> DominanceFrontiers {
        DominanceFrontiers::new(cfg, dominator_tree)
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::cfg::{BasicBlock, BlockKind, Terminator, EdgeType};
        use crate::cfg::dominators::DominatorTree;
        use petgraph::graph::DiGraph;

        /// Create a simple diamond CFG:
        ///     0 (entry)
        ///    / \
        ///   1   2
        ///    \ /
        ///     3 (exit)
        fn create_diamond_cfg() -> Cfg {
            let mut g = DiGraph::new();

            let b0 = g.add_node(BasicBlock {
                id: 0,
                kind: BlockKind::Entry,
                statements: vec![],
                terminator: Terminator::SwitchInt { targets: vec![1], otherwise: 2 },
                source_location: None,
            });

            let b1 = g.add_node(BasicBlock {
                id: 1,
                kind: BlockKind::Normal,
                statements: vec!["branch 1".to_string()],
                terminator: Terminator::Goto { target: 3 },
                source_location: None,
            });

            let b2 = g.add_node(BasicBlock {
                id: 2,
                kind: BlockKind::Normal,
                statements: vec!["branch 2".to_string()],
                terminator: Terminator::Goto { target: 3 },
                source_location: None,
            });

            let b3 = g.add_node(BasicBlock {
                id: 3,
                kind: BlockKind::Exit,
                statements: vec![],
                terminator: Terminator::Return,
                source_location: None,
            });

            g.add_edge(b0, b1, EdgeType::TrueBranch);
            g.add_edge(b0, b2, EdgeType::FalseBranch);
            g.add_edge(b1, b3, EdgeType::Fallthrough);
            g.add_edge(b2, b3, EdgeType::Fallthrough);

            g
        }

        /// Create CFG with loop:
        ///     0 (entry)
        ///     |
        ///     1 (header: if condition)
        ///    / \
        ///   2   3 (exit)
        ///   |
        ///   1 (back edge)
        fn create_loop_cfg() -> Cfg {
            let mut g = DiGraph::new();

            let b0 = g.add_node(BasicBlock {
                id: 0,
                kind: BlockKind::Entry,
                statements: vec![],
                terminator: Terminator::Goto { target: 1 },
                source_location: None,
            });

            let b1 = g.add_node(BasicBlock {
                id: 1,
                kind: BlockKind::Normal,
                statements: vec![],
                terminator: Terminator::SwitchInt { targets: vec![2], otherwise: 3 },
                source_location: None,
            });

            let b2 = g.add_node(BasicBlock {
                id: 2,
                kind: BlockKind::Normal,
                statements: vec!["loop body".to_string()],
                terminator: Terminator::Goto { target: 1 },
                source_location: None,
            });

            let b3 = g.add_node(BasicBlock {
                id: 3,
                kind: BlockKind::Exit,
                statements: vec![],
                terminator: Terminator::Return,
                source_location: None,
            });

            g.add_edge(b0, b1, EdgeType::Fallthrough);
            g.add_edge(b1, b2, EdgeType::TrueBranch);
            g.add_edge(b1, b3, EdgeType::FalseBranch);
            g.add_edge(b2, b1, EdgeType::LoopBack);

            g
        }

        #[test]
        fn test_dominance_frontiers_diamond() {
            let cfg = create_diamond_cfg();
            let dom_tree = DominatorTree::new(&cfg).expect("CFG has entry");
            let frontiers = DominanceFrontiers::new(&cfg, dom_tree);

            // In diamond CFG, entry (0) dominates 1 and 2, but not 3
            // DF[0] = {3} because 0 dominates pred(3) but not 3 itself
            let df0 = frontiers.frontier(NodeIndex::new(0));
            assert!(df0.contains(&NodeIndex::new(3)));
            assert_eq!(df0.len(), 1);

            // Nodes 1 and 2 have no dominance frontier (no successors with multiple preds)
            assert!(frontiers.frontier(NodeIndex::new(1)).is_empty());
            assert!(frontiers.frontier(NodeIndex::new(2)).is_empty());
        }

        #[test]
        fn test_dominance_frontiers_loop() {
            let cfg = create_loop_cfg();
            let dom_tree = DominatorTree::new(&cfg).expect("CFG has entry");
            let frontiers = DominanceFrontiers::new(&cfg, dom_tree);

            // Entry (0) dominates everything, DF[0] is empty
            assert!(frontiers.frontier(NodeIndex::new(0)).is_empty());

            // Loop header (1) dominates 2, DF[1] contains 1 (self-loop creates frontier at exit)
            // Actually in this CFG: 1 dominates 2, and 1 is target of back edge from 2
            // The exit point (3) has preds from 1, and 1 dominates 1 but not 3
            let df1 = frontiers.frontier(NodeIndex::new(1));
            // Node 3 has predecessor 1, and 1 doesn't strictly dominate 3
            assert!(df1.contains(&NodeIndex::new(3)));

            // Loop body (2) has no frontier
            assert!(frontiers.frontier(NodeIndex::new(2)).is_empty());
        }

        #[test]
        fn test_in_frontier() {
            let cfg = create_diamond_cfg();
            let dom_tree = DominatorTree::new(&cfg).expect("CFG has entry");
            let frontiers = DominanceFrontiers::new(&cfg, dom_tree);

            // 3 is in 0's dominance frontier
            assert!(frontiers.in_frontier(NodeIndex::new(0), NodeIndex::new(3)));

            // 1 is NOT in 0's dominance frontier
            assert!(!frontiers.in_frontier(NodeIndex::new(0), NodeIndex::new(1)));
        }

        #[test]
        fn test_nodes_with_frontiers() {
            let cfg = create_diamond_cfg();
            let dom_tree = DominatorTree::new(&cfg).expect("CFG has entry");
            let frontiers = DominanceFrontiers::new(&cfg, dom_tree);

            let nodes: Vec<_> = frontiers.nodes_with_frontiers().collect();
            // Only node 0 (entry) should have non-empty frontier in diamond CFG
            assert_eq!(nodes.len(), 1);
            assert_eq!(nodes[0], NodeIndex::new(0));
        }

        #[test]
        fn test_iterated_frontier() {
            let cfg = create_diamond_cfg();
            let dom_tree = DominatorTree::new(&cfg).expect("CFG has entry");
            let frontiers = DominanceFrontiers::new(&cfg, dom_tree);

            // Iterated frontier of {0} should include {3}
            let idf = frontiers.iterated_frontier(&[NodeIndex::new(0)]);
            assert!(idf.contains(&NodeIndex::new(3)));
        }

        #[test]
        fn test_union_frontier() {
            let cfg = create_diamond_cfg();
            let dom_tree = DominatorTree::new(&cfg).expect("CFG has entry");
            let frontiers = DominanceFrontiers::new(&cfg, dom_tree);

            // Union frontier of {0, 1} should include {3}
            let union = frontiers.union_frontier(&[NodeIndex::new(0), NodeIndex::new(1)]);
            assert!(union.contains(&NodeIndex::new(3)));
        }

        #[test]
        fn test_linear_cfg() {
            // Linear CFG: 0 -> 1 -> 2 -> 3
            let mut g = DiGraph::new();

            let b0 = g.add_node(BasicBlock {
                id: 0,
                kind: BlockKind::Entry,
                statements: vec![],
                terminator: Terminator::Goto { target: 1 },
                source_location: None,
            });

            let b1 = g.add_node(BasicBlock {
                id: 1,
                kind: BlockKind::Normal,
                statements: vec![],
                terminator: Terminator::Goto { target: 2 },
                source_location: None,
            });

            let b2 = g.add_node(BasicBlock {
                id: 2,
                kind: BlockKind::Normal,
                statements: vec![],
                terminator: Terminator::Goto { target: 3 },
                source_location: None,
            });

            let b3 = g.add_node(BasicBlock {
                id: 3,
                kind: BlockKind::Exit,
                statements: vec![],
                terminator: Terminator::Return,
                source_location: None,
            });

            g.add_edge(b0, b1, EdgeType::Fallthrough);
            g.add_edge(b1, b2, EdgeType::Fallthrough);
            g.add_edge(b2, b3, EdgeType::Fallthrough);

            let dom_tree = DominatorTree::new(&g).expect("CFG has entry");
            let frontiers = DominanceFrontiers::new(&g, dom_tree);

            // Linear CFG has no dominance frontiers (no join points)
            for node in g.node_indices() {
                assert!(frontiers.frontier(node).is_empty(),
                    "Linear CFG should have empty dominance frontiers");
            }
        }

        #[test]
        fn test_complex_join() {
            // Create CFG with multiple join points:
            //       0
            //      /|\
            //     1 2 3
            //     \|/ |
            //      4  |
            //      \ /
            //       5
            let mut g = DiGraph::new();

            let b0 = g.add_node(BasicBlock {
                id: 0,
                kind: BlockKind::Entry,
                statements: vec![],
                terminator: Terminator::SwitchInt { targets: vec![1, 2], otherwise: 3 },
                source_location: None,
            });

            let b1 = g.add_node(BasicBlock {
                id: 1,
                kind: BlockKind::Normal,
                statements: vec![],
                terminator: Terminator::Goto { target: 4 },
                source_location: None,
            });

            let b2 = g.add_node(BasicBlock {
                id: 2,
                kind: BlockKind::Normal,
                statements: vec![],
                terminator: Terminator::Goto { target: 4 },
                source_location: None,
            });

            let b3 = g.add_node(BasicBlock {
                id: 3,
                kind: BlockKind::Normal,
                statements: vec![],
                terminator: Terminator::Goto { target: 5 },
                source_location: None,
            });

            let b4 = g.add_node(BasicBlock {
                id: 4,
                kind: BlockKind::Normal,
                statements: vec![],
                terminator: Terminator::Goto { target: 5 },
                source_location: None,
            });

            let b5 = g.add_node(BasicBlock {
                id: 5,
                kind: BlockKind::Exit,
                statements: vec![],
                terminator: Terminator::Return,
                source_location: None,
            });

            g.add_edge(b0, b1, EdgeType::Fallthrough);
            g.add_edge(b0, b2, EdgeType::Fallthrough);
            g.add_edge(b0, b3, EdgeType::Fallthrough);
            g.add_edge(b1, b4, EdgeType::Fallthrough);
            g.add_edge(b2, b4, EdgeType::Fallthrough);
            g.add_edge(b3, b5, EdgeType::Fallthrough);
            g.add_edge(b4, b5, EdgeType::Fallthrough);

            let dom_tree = DominatorTree::new(&g).expect("CFG has entry");
            let frontiers = DominanceFrontiers::new(&g, dom_tree);

            // Node 0 dominates 1, 2, 3 but not 4, 5
            // DF[0] = {4, 5} (join points)
            let df0 = frontiers.frontier(b0);
            assert!(df0.contains(&b4));
            assert!(df0.contains(&b5));
        }

        #[test]
        fn test_empty_cfg() {
            let cfg: Cfg = DiGraph::new();
            let dom_tree = DominatorTree::new(&cfg);
            assert!(dom_tree.is_none());
        }
    }
    ```

    2. Update src/cfg/mod.rs:
       Add to module declarations:
       ```rust
       pub mod dominance_frontiers;
       pub use dominance_frontiers::{DominanceFrontiers, compute_dominance_frontiers};
       ```
  </action>
  <verify>cargo check passes without errors</verify>
  <done>dominance_frontiers module created with DominanceFrontiers struct and comprehensive tests</done>
</task>

</tasks>

<verification>
1. Type checking: cargo check passes with no errors
2. Module visibility: DominanceFrontiers and compute_dominance_frontiers exported from crate root
3. Test coverage: Diamond CFG, loop CFG, linear CFG, complex join all tested
4. Algorithm correctness: Cytron et al. algorithm with both rules implemented
5. Edge cases: Empty CFG handled gracefully
</verification>

<success_criteria>
- [ ] src/cfg/dominance_frontiers.rs exists with DominanceFrontiers struct
- [ ] DominanceFrontiers::new() computes frontiers using Cytron et al. algorithm
- [ ] frontier(node) returns HashSet of nodes in node's dominance frontier
- [ ] in_frontier(n, v) correctly checks membership
- [ ] iterated_frontier() computes closure under dominance relation
- [ ] union_frontier() computes union of multiple nodes' frontiers
- [ ] nodes_with_frontiers() returns nodes with non-empty frontiers
- [ ] Diamond CFG: DF[entry] = {merge_point}
- [ ] Linear CFG: All dominance frontiers empty
- [ ] Loop CFG: Correctly identifies exit in header's frontier
- [ ] All functions exported from crate root
- [ ] cargo test --lib dominance_frontiers passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-dominance-analysis/04-03-SUMMARY.md`
</output>
