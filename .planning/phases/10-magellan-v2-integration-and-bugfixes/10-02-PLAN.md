---
phase: 10-magellan-v2-integration-and-bugfixes
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/analysis/mod.rs
  - src/cli/mod.rs
autonomous: true

must_haves:
  truths:
    - "unreachable command shows both uncalled functions and unreachable blocks"
    - "MagellanBridge::dead_symbols() returns uncalled functions"
    - "CLI unreachable command integrates call graph dead code"
  artifacts:
    - path: "src/analysis/mod.rs"
      provides: "Enhanced dead code detection combining Magellan + Mirage"
      exports: ["EnhancedDeadCode", "MagellanBridge::dead_symbols"]
    - path: "src/cli/mod.rs"
      contains: "unreachable command with --include-uncalled flag"
  key_links:
    - from: "src/cli/mod.rs"
      to: "src/analysis/mod.rs"
      via: "MagellanBridge::dead_symbols()"
      pattern: "magellan_bridge\\.dead_symbols"
---

<objective>
Enhance the unreachable command to combine Magellan's uncalled functions detection (inter-procedural) with Mirage's unreachable block detection (intra-procedural).

Purpose: Complete dead code detection - find both functions that are never called AND blocks within functions that can never execute.

Output: unreachable command with --include-uncalled flag shows combined dead code report.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-magellan-v2-integration-and-bugfixes/10-RESEARCH.md
@.planning/phases/10-magellan-v2-integration-and-bugfixes/10-01-SUMMARY.md

# Existing unreachable command
src/cli/mod.rs has unreachable command - only shows intra-function unreachable blocks
src/cfg/reachability.rs has find_unreachable() function
</context>

<tasks>

<task type="auto">
  <name>Add dead_symbols wrapper to MagellanBridge</name>
  <files>src/analysis/mod.rs</files>
  <action>
  Add to src/analysis/mod.rs:

  1. Add EnhancedDeadCode response struct:
     ```rust
     use serde::Serialize;

     #[derive(Debug, Clone, Serialize)]
     pub struct EnhancedDeadCode {
         /// From Magellan: Functions never called from entry
         pub uncalled_functions: Vec<DeadSymbol>,
         /// From Mirage: Unreachable blocks within functions
         pub unreachable_blocks: std::collections::HashMap<String, Vec<usize>>,
         /// Total count of dead code items
         pub total_dead_count: usize,
     }
     ```

  2. Add method to MagellanBridge:
     ```rust
     use magellan::{DeadSymbol, SymbolInfo};

     impl MagellanBridge {
         /// Find uncalled functions from entry point
         ///
         /// # Arguments
         /// * `entry_symbol` - Symbol ID or FQN of entry point (e.g., "main")
         ///
         /// Returns list of symbols unreachable from entry
         pub fn dead_symbols(&self, entry_symbol: &str) -> Result<Vec<DeadSymbol>> {
             self.graph.dead_symbols(entry_symbol)
         }
     }
     ```

  3. Import DeadSymbol from magellan::graph::algorithms
  </action>
  <verify>cargo check passes, DeadSymbol compiles</verify>
  <done>MagellanBridge has dead_symbols() method</done>
</task>

<task type="auto">
  <name>Add --include-uncalled flag to unreachable CLI</name>
  <files>src/cli/mod.rs</files>
  <action>
  1. Update UnreachableArgs struct:
     ```rust
     #[derive(Parser, Debug, Clone)]
     pub struct UnreachableArgs {
         /// Find unreachable code within functions
         #[arg(long)]
         pub within_functions: bool,

         /// Show branch details
         #[arg(long)]
         pub show_branches: bool,

         /// Include uncalled functions (requires Magellan call graph)
         #[arg(long)]
         pub include_uncalled: bool,
     }
     ```

  2. In unreachable command handler, when --include-uncalled is true:
     - Open MagellanBridge with same db path
     - Call magellan_bridge.dead_symbols("main") (or detect entry point)
     - Combine results with existing unreachable blocks
     - Return EnhancedDeadCode in JSON output

  3. Add UnreachableResponse enhancement:
     ```rust
     #[derive(serde::Serialize)]
     struct UnreachableResponse {
         // ... existing fields ...
         uncalled_functions: Option<Vec<DeadSymbol>>,
     }
     ```

  4. For human output, show:
     - Section: "Uncalled Functions (N)" with list
     - Section: "Unreachable Blocks (M)" with existing output
  </action>
  <verify>cargo check passes, unreachable command compiles</verify>
  <done>--include-uncalled flag added to unreachable command</done>
</task>

<task type="auto">
  <name>Test combined dead code detection</name>
  <files>src/cli/mod.rs</files>
  <action>
  1. Create integration test using MirageDb test database:
     - Insert test functions in graph_entities
     - Create unreachable blocks in some functions
     - Run unreachable command with --include-uncalled
     - Verify both uncalled functions and unreachable blocks are reported

  2. Test entry point detection:
     - Default to "main" as entry symbol
     - Handle case when main doesn't exist (show helpful message)

  3. Add doctest example for MagellanBridge::dead_symbols()
  </action>
  <verify>cargo test passes for unreachable tests</verify>
  <done>Combined dead code detection tested</done>
</task>

</tasks>

<verification>
1. `mirage unreachable --include-uncalled` shows both uncalled functions and unreachable blocks
2. JSON output includes uncalled_functions array
3. Human output has separate sections for each type of dead code
4. All tests pass
</verification>

<success_criteria>
1. --include-uncalled flag works on unreachable command
2. Magellan dead_symbols API integrated
3. Output format shows both inter and intra procedural dead code
4. Error handling for missing entry point
</success_criteria>

<output>
After completion, create `.planning/phases/10-magellan-v2-integration-and-bugfixes/10-02-SUMMARY.md`
</output>
